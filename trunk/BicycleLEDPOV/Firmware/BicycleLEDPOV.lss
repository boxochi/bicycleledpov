
BicycleLEDPOV.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00800100  00000dae  00000e22  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000dae  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000036  0080011c  00000dca  00000e3e  2**0
                  ALLOC
  3 .stab         00000378  00000000  00000000  00000e40  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000054  00000000  00000000  000011b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000002c8  00000000  00000000  0000120c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000627  00000000  00000000  000014d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002a7a  00000000  00000000  00001afb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000f8b  00000000  00000000  00004575  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002295  00000000  00000000  00005500  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000350  00000000  00000000  00007798  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001135  00000000  00000000  00007ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000008a4  00000000  00000000  00008c1d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000090  00000000  00000000  000094c1  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
		}
	}
}
	
void Hardware_Init(void)
{
   0:	9f c0       	rjmp	.+318    	; 0x140 <__ctors_end>

volatile SchedulerDelayCounter_t Scheduler_TickCounter;
volatile uint8_t                 Scheduler_TotalTasks;

bool Scheduler_HasDelayElapsed(const uint16_t Delay, SchedulerDelayCounter_t* const DelayCounter)
{
   2:	00 00       	nop
	
	Endpoint_AllocateMemory();
}

void Endpoint_ClearEndpoints(void)
{
   4:	b8 c0       	rjmp	.+368    	; 0x176 <__bad_interrupt>
  while(bit_is_clear(SPSR,SPIF))
    ;
}

unsigned char SPI_MasterReceive(void)
{
   6:	00 00       	nop
   8:	b6 c0       	rjmp	.+364    	; 0x176 <__bad_interrupt>
   a:	00 00       	nop
   c:	b4 c0       	rjmp	.+360    	; 0x176 <__bad_interrupt>
   e:	00 00       	nop
  10:	b2 c0       	rjmp	.+356    	; 0x176 <__bad_interrupt>
  12:	00 00       	nop
  14:	b0 c0       	rjmp	.+352    	; 0x176 <__bad_interrupt>
  16:	00 00       	nop
  18:	ae c0       	rjmp	.+348    	; 0x176 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	ac c0       	rjmp	.+344    	; 0x176 <__bad_interrupt>
  1e:	00 00       	nop
  20:	aa c0       	rjmp	.+340    	; 0x176 <__bad_interrupt>
  22:	00 00       	nop
  24:	a8 c0       	rjmp	.+336    	; 0x176 <__bad_interrupt>
  26:	00 00       	nop
  28:	a6 c0       	rjmp	.+332    	; 0x176 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	fa c5       	rjmp	.+3060   	; 0xc22 <__vector_11>
  2e:	00 00       	nop
  30:	a2 c0       	rjmp	.+324    	; 0x176 <__bad_interrupt>
  32:	00 00       	nop
  34:	a0 c0       	rjmp	.+320    	; 0x176 <__bad_interrupt>
  36:	00 00       	nop
  38:	9e c0       	rjmp	.+316    	; 0x176 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	9c c0       	rjmp	.+312    	; 0x176 <__bad_interrupt>
  3e:	00 00       	nop
  40:	9a c0       	rjmp	.+308    	; 0x176 <__bad_interrupt>
  42:	00 00       	nop
  44:	98 c0       	rjmp	.+304    	; 0x176 <__bad_interrupt>
  46:	00 00       	nop
  48:	96 c0       	rjmp	.+300    	; 0x176 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	95 c0       	rjmp	.+298    	; 0x178 <__vector_19>
  4e:	00 00       	nop
  50:	92 c0       	rjmp	.+292    	; 0x176 <__bad_interrupt>
  52:	00 00       	nop
  54:	90 c0       	rjmp	.+288    	; 0x176 <__bad_interrupt>
  56:	00 00       	nop
  58:	8e c0       	rjmp	.+284    	; 0x176 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	8c c0       	rjmp	.+280    	; 0x176 <__bad_interrupt>
  5e:	00 00       	nop
  60:	8a c0       	rjmp	.+276    	; 0x176 <__bad_interrupt>
  62:	00 00       	nop
  64:	88 c0       	rjmp	.+272    	; 0x176 <__bad_interrupt>
  66:	00 00       	nop
  68:	86 c0       	rjmp	.+268    	; 0x176 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	84 c0       	rjmp	.+264    	; 0x176 <__bad_interrupt>
  6e:	00 00       	nop
  70:	82 c0       	rjmp	.+260    	; 0x176 <__bad_interrupt>
  72:	00 00       	nop

00000074 <DeviceDescriptor>:
  74:	12 01 10 01 02 00 00 08 eb 03 4b 20 00 00 01 02     ..........K ....
  84:	03 01                                               ..

00000086 <ConfigurationDescriptor>:
  86:	09 02 43 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..C.....2.......
  96:	01 00 05 24 00 10 01 05 24 01 03 01 04 24 02 06     ...$....$....$..
  a6:	05 24 06 00 01 07 05 82 03 08 00 02 09 04 01 00     .$..............
  b6:	02 0a 00 00 00 07 05 04 02 10 00 00 07 05 83 02     ................
  c6:	10 00 00                                            ...

000000c9 <LanguageString>:
  c9:	04 03 09 04                                         ....

000000cd <ManafacturerString>:
  cd:	18 03 4a 00 6f 00 72 00 67 00 65 00 20 00 50 00     ..J.o.r.g.e. .P.
  dd:	69 00 6e 00 74 00 6f 00 20 00 61 00 6b 00 61 00     i.n.t.o. .a.k.a.
  ed:	20 00 43 00 61 00 73 00 61 00 69 00 6e 00 68 00      .C.a.s.a.i.n.h.
  fd:	6f 00 00 00                                         o...

00000101 <ProductString>:
 101:	2a 03 42 00 69 00 63 00 79 00 63 00 6c 00 65 00     *.B.i.c.y.c.l.e.
 111:	20 00 4c 00 45 00 44 00 20 00 50 00 4f 00 56 00      .L.E.D. .P.O.V.
 121:	00 00                                               ..

00000123 <SerialNumberString>:
 123:	1a 03 30 00 30 00 30 00 30 00 30 00 30 00 30 00     ..0.0.0.0.0.0.0.
 133:	30 00 30 00 30 00 30 00 30 00 00 00 00              0.0.0.0.0....

00000140 <__ctors_end>:
 140:	11 24       	eor	r1, r1
 142:	1f be       	out	0x3f, r1	; 63
 144:	cf ef       	ldi	r28, 0xFF	; 255
 146:	d2 e0       	ldi	r29, 0x02	; 2
 148:	de bf       	out	0x3e, r29	; 62
 14a:	cd bf       	out	0x3d, r28	; 61

0000014c <__do_copy_data>:
 14c:	11 e0       	ldi	r17, 0x01	; 1
 14e:	a0 e0       	ldi	r26, 0x00	; 0
 150:	b1 e0       	ldi	r27, 0x01	; 1
 152:	ee ea       	ldi	r30, 0xAE	; 174
 154:	fd e0       	ldi	r31, 0x0D	; 13
 156:	02 c0       	rjmp	.+4      	; 0x15c <.do_copy_data_start>

00000158 <.do_copy_data_loop>:
 158:	05 90       	lpm	r0, Z+
 15a:	0d 92       	st	X+, r0

0000015c <.do_copy_data_start>:
 15c:	ac 31       	cpi	r26, 0x1C	; 28
 15e:	b1 07       	cpc	r27, r17
 160:	d9 f7       	brne	.-10     	; 0x158 <.do_copy_data_loop>

00000162 <__do_clear_bss>:
 162:	11 e0       	ldi	r17, 0x01	; 1
 164:	ac e1       	ldi	r26, 0x1C	; 28
 166:	b1 e0       	ldi	r27, 0x01	; 1
 168:	01 c0       	rjmp	.+2      	; 0x16c <.do_clear_bss_start>

0000016a <.do_clear_bss_loop>:
 16a:	1d 92       	st	X+, r1

0000016c <.do_clear_bss_start>:
 16c:	a2 35       	cpi	r26, 0x52	; 82
 16e:	b1 07       	cpc	r27, r17
 170:	e1 f7       	brne	.-8      	; 0x16a <.do_clear_bss_loop>
 172:	11 d1       	rcall	.+546    	; 0x396 <main>
 174:	1b c6       	rjmp	.+3126   	; 0xdac <_exit>

00000176 <__bad_interrupt>:
 176:	44 cf       	rjmp	.-376    	; 0x0 <__heap_end>

00000178 <__vector_19>:
RingBuff_t        Tx_Buffer;

unsigned char rxbuff, txbuff, rxbuffele, txbuffele;

ISR(TIMER0_COMPA_vect, ISR_BLOCK)
{
 178:	1f 92       	push	r1
 17a:	0f 92       	push	r0
 17c:	0f b6       	in	r0, 0x3f	; 63
 17e:	0f 92       	push	r0
 180:	11 24       	eor	r1, r1
 182:	8f 93       	push	r24
 184:	9f 93       	push	r25
	/* Scheduler test - increment scheduler tick counter once each millisecond */
	Scheduler_TickCounter++;
 186:	80 91 4d 01 	lds	r24, 0x014D
 18a:	90 91 4e 01 	lds	r25, 0x014E
 18e:	01 96       	adiw	r24, 0x01	; 1
 190:	90 93 4e 01 	sts	0x014E, r25
 194:	80 93 4d 01 	sts	0x014D, r24
 198:	9f 91       	pop	r25
 19a:	8f 91       	pop	r24
 19c:	0f 90       	pop	r0
 19e:	0f be       	out	0x3f, r0	; 63
 1a0:	0f 90       	pop	r0
 1a2:	1f 90       	pop	r1
 1a4:	18 95       	reti

000001a6 <MakePOV_Task>:
	TCCR0B = ((1 << CS01) | (1 << CS00));
	TIMSK0 = (1 << OCIE0A);
}

TASK(MakePOV_Task)
{
 1a6:	5c 9a       	sbi	0x0b, 4	; 11
 1a8:	08 95       	ret

000001aa <TestSensorHallEffect_Task>:
	PORTD |= (1<<PD4); /* Turn on LED */
}

TASK(TestSensorHallEffect_Task)
{
 1aa:	48 99       	sbic	0x09, 0	; 9
 1ac:	02 c0       	rjmp	.+4      	; 0x1b2 <TestSensorHallEffect_Task+0x8>
	if (bit_is_clear(PIND,PD0))
	{
		PORTD |= (1<<PD4); /* Turn on LED */
 1ae:	5c 9a       	sbi	0x0b, 4	; 11
 1b0:	08 95       	ret
	}
	
	else
	{
		PORTD &= ~(1<<PD4); /* Turn off LED */
 1b2:	5c 98       	cbi	0x0b, 4	; 11
 1b4:	08 95       	ret

000001b6 <CDC_Task>:
			break;
	}
}

TASK(CDC_Task)
{
 1b6:	1f 93       	push	r17
 1b8:	cf 93       	push	r28
 1ba:	df 93       	push	r29
	if (USB_IsConnected)
 1bc:	80 91 51 01 	lds	r24, 0x0151
 1c0:	88 23       	and	r24, r24
 1c2:	09 f4       	brne	.+2      	; 0x1c6 <CDC_Task+0x10>
 1c4:	48 c0       	rjmp	.+144    	; 0x256 <CDC_Task+0xa0>
	{
		/* Select the Serial Rx Endpoint */
		Endpoint_SelectEndpoint(CDC_RX_EPNUM);
 1c6:	84 e0       	ldi	r24, 0x04	; 4
 1c8:	80 93 e9 00 	sts	0x00E9, r24
		
		if (Endpoint_ReadWriteAllowed())
 1cc:	80 91 e8 00 	lds	r24, 0x00E8
 1d0:	85 fd       	sbrc	r24, 5
 1d2:	0a c0       	rjmp	.+20     	; 0x1e8 <CDC_Task+0x32>
 1d4:	14 c0       	rjmp	.+40     	; 0x1fe <CDC_Task+0x48>
		{
			/* Read the recieved data endpoint into the transmission buffer */
			while (Endpoint_BytesInEndpoint())
			{
				/* Wait until the buffer has space for a new character */
				while (!((BUFF_STATICSIZE - Rx_Buffer.Elements)));
 1d6:	80 91 4a 01 	lds	r24, 0x014A
 1da:	80 31       	cpi	r24, 0x10	; 16
 1dc:	e1 f3       	breq	.-8      	; 0x1d6 <CDC_Task+0x20>
		/* Inline Functions: */
			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 1de:	60 91 f1 00 	lds	r22, 0x00F1
			
				/* Store each character from the endpoint */
				Buffer_StoreElement(&Rx_Buffer, Endpoint_Read_Byte());
 1e2:	ce 01       	movw	r24, r28
 1e4:	5b d2       	rcall	.+1206   	; 0x69c <Buffer_StoreElement>
 1e6:	02 c0       	rjmp	.+4      	; 0x1ec <CDC_Task+0x36>
 1e8:	c6 e3       	ldi	r28, 0x36	; 54
 1ea:	d1 e0       	ldi	r29, 0x01	; 1
		Endpoint_SelectEndpoint(CDC_RX_EPNUM);
		
		if (Endpoint_ReadWriteAllowed())
		{
			/* Read the recieved data endpoint into the transmission buffer */
			while (Endpoint_BytesInEndpoint())
 1ec:	80 91 f2 00 	lds	r24, 0x00F2
 1f0:	88 23       	and	r24, r24
 1f2:	89 f7       	brne	.-30     	; 0x1d6 <CDC_Task+0x20>
				/* Store each character from the endpoint */
				Buffer_StoreElement(&Rx_Buffer, Endpoint_Read_Byte());
			}
			
			/* Clear the endpoint buffer */
			Endpoint_ClearCurrentBank();
 1f4:	80 91 e8 00 	lds	r24, 0x00E8
 1f8:	8f 77       	andi	r24, 0x7F	; 127
 1fa:	80 93 e8 00 	sts	0x00E8, r24
		}

		/* Select the Serial Tx Endpoint */
		Endpoint_SelectEndpoint(CDC_TX_EPNUM);
 1fe:	83 e0       	ldi	r24, 0x03	; 3
 200:	80 93 e9 00 	sts	0x00E9, r24

		/* Check if the Tx buffer contains anything to be sent to the host */
		if (Tx_Buffer.Elements)
 204:	80 91 35 01 	lds	r24, 0x0135
 208:	88 23       	and	r24, r24
 20a:	29 f1       	breq	.+74     	; 0x256 <CDC_Task+0xa0>
		{
			/* Wait until Serial Tx Endpoint Ready for Read/Write */
			while (!(Endpoint_ReadWriteAllowed()));
 20c:	80 91 e8 00 	lds	r24, 0x00E8
 210:	85 ff       	sbrs	r24, 5
 212:	fc cf       	rjmp	.-8      	; 0x20c <CDC_Task+0x56>
			
			/* Check before sending the data if the endpoint is completely full */
			bool IsFull = (Endpoint_BytesInEndpoint() == CDC_TXRX_EPSIZE);
 214:	10 91 f2 00 	lds	r17, 0x00F2
 218:	c1 e2       	ldi	r28, 0x21	; 33
 21a:	d1 e0       	ldi	r29, 0x01	; 1
 21c:	04 c0       	rjmp	.+8      	; 0x226 <CDC_Task+0x70>
			
			/* Write the transmission buffer contents to the recieved data endpoint */
			while (Tx_Buffer.Elements && (Endpoint_BytesInEndpoint() < CDC_TXRX_EPSIZE))
			  Endpoint_Write_Byte(Buffer_GetElement(&Tx_Buffer));
 21e:	ce 01       	movw	r24, r28
 220:	0f d2       	rcall	.+1054   	; 0x640 <Buffer_GetElement>
			}

			/** Writes one byte from the currently selected endpoint's bank, for IN direction endpoints. */
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 222:	80 93 f1 00 	sts	0x00F1, r24
			
			/* Check before sending the data if the endpoint is completely full */
			bool IsFull = (Endpoint_BytesInEndpoint() == CDC_TXRX_EPSIZE);
			
			/* Write the transmission buffer contents to the recieved data endpoint */
			while (Tx_Buffer.Elements && (Endpoint_BytesInEndpoint() < CDC_TXRX_EPSIZE))
 226:	80 91 35 01 	lds	r24, 0x0135
 22a:	88 23       	and	r24, r24
 22c:	21 f0       	breq	.+8      	; 0x236 <CDC_Task+0x80>
 22e:	80 91 f2 00 	lds	r24, 0x00F2
 232:	80 31       	cpi	r24, 0x10	; 16
 234:	a0 f3       	brcs	.-24     	; 0x21e <CDC_Task+0x68>
			  Endpoint_Write_Byte(Buffer_GetElement(&Tx_Buffer));
			
			/* Send the data */
			Endpoint_ClearCurrentBank();
 236:	80 91 e8 00 	lds	r24, 0x00E8
 23a:	8f 77       	andi	r24, 0x7F	; 127
 23c:	80 93 e8 00 	sts	0x00E8, r24

			/* If a full endpoint was sent, we need to send an empty packet afterwards to terminate the transfer */
			if (IsFull)
 240:	10 31       	cpi	r17, 0x10	; 16
 242:	49 f4       	brne	.+18     	; 0x256 <CDC_Task+0xa0>
			{
				/* Wait until Serial Tx Endpoint Ready for Read/Write */
				while (!(Endpoint_ReadWriteAllowed()));
 244:	80 91 e8 00 	lds	r24, 0x00E8
 248:	85 ff       	sbrs	r24, 5
 24a:	fc cf       	rjmp	.-8      	; 0x244 <CDC_Task+0x8e>

				/* Send an empty packet to terminate the transfer */
				Endpoint_ClearCurrentBank();
 24c:	80 91 e8 00 	lds	r24, 0x00E8
 250:	8f 77       	andi	r24, 0x7F	; 127
 252:	80 93 e8 00 	sts	0x00E8, r24
 256:	df 91       	pop	r29
 258:	cf 91       	pop	r28
 25a:	1f 91       	pop	r17
 25c:	08 95       	ret

0000025e <Event_USB_Disconnect>:
	Scheduler_SetTaskMode(USB_USBTask, TASK_RUN);
	Scheduler_SetTaskMode(MakePOV_Task, TASK_STOP);
}

EVENT_HANDLER(USB_Disconnect)
{
 25e:	60 e0       	ldi	r22, 0x00	; 0
 260:	8e ef       	ldi	r24, 0xFE	; 254
 262:	95 e0       	ldi	r25, 0x05	; 5
 264:	4d d2       	rcall	.+1178   	; 0x700 <Scheduler_SetTaskMode>
	Scheduler_SetTaskMode(USB_USBTask, TASK_STOP);
	Scheduler_SetTaskMode(CDC_Task, TASK_STOP);
 266:	60 e0       	ldi	r22, 0x00	; 0
 268:	8b ed       	ldi	r24, 0xDB	; 219
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	49 d2       	rcall	.+1170   	; 0x700 <Scheduler_SetTaskMode>
	Scheduler_SetTaskMode(PCLink_Task, TASK_STOP);
 26e:	60 e0       	ldi	r22, 0x00	; 0
 270:	8a e0       	ldi	r24, 0x0A	; 10
 272:	92 e0       	ldi	r25, 0x02	; 2
 274:	45 d2       	rcall	.+1162   	; 0x700 <Scheduler_SetTaskMode>
	Scheduler_SetTaskMode(TestSensorHallEffect_Task, TASK_STOP);
 276:	60 e0       	ldi	r22, 0x00	; 0
 278:	85 ed       	ldi	r24, 0xD5	; 213
 27a:	90 e0       	ldi	r25, 0x00	; 0
 27c:	41 d2       	rcall	.+1154   	; 0x700 <Scheduler_SetTaskMode>
	Scheduler_SetTaskMode(MakePOV_Task, TASK_RUN);
 27e:	61 e0       	ldi	r22, 0x01	; 1
 280:	83 ed       	ldi	r24, 0xD3	; 211
 282:	90 e0       	ldi	r25, 0x00	; 0
 284:	3d c2       	rjmp	.+1146   	; 0x700 <Scheduler_SetTaskMode>

00000286 <Event_USB_Connect>:
	/* Scheduling - routine never returns, so put this last in the main function */
	Scheduler_Start();
}

EVENT_HANDLER(USB_Connect)
{
 286:	61 e0       	ldi	r22, 0x01	; 1
 288:	8e ef       	ldi	r24, 0xFE	; 254
 28a:	95 e0       	ldi	r25, 0x05	; 5
 28c:	39 d2       	rcall	.+1138   	; 0x700 <Scheduler_SetTaskMode>
	/* Start USB management task */
	Scheduler_SetTaskMode(USB_USBTask, TASK_RUN);
	Scheduler_SetTaskMode(MakePOV_Task, TASK_STOP);
 28e:	60 e0       	ldi	r22, 0x00	; 0
 290:	83 ed       	ldi	r24, 0xD3	; 211
 292:	90 e0       	ldi	r25, 0x00	; 0
 294:	35 c2       	rjmp	.+1130   	; 0x700 <Scheduler_SetTaskMode>

00000296 <Event_USB_ConfigurationChanged>:
	Scheduler_SetTaskMode(TestSensorHallEffect_Task, TASK_STOP);
	Scheduler_SetTaskMode(MakePOV_Task, TASK_RUN);
}

EVENT_HANDLER(USB_ConfigurationChanged)
{
 296:	20 e0       	ldi	r18, 0x00	; 0
 298:	41 ec       	ldi	r20, 0xC1	; 193
 29a:	68 e0       	ldi	r22, 0x08	; 8
 29c:	70 e0       	ldi	r23, 0x00	; 0
 29e:	82 e0       	ldi	r24, 0x02	; 2
 2a0:	cf d2       	rcall	.+1438   	; 0x840 <Endpoint_ConfigureEndpoint_P>
	/* Setup CDC Notification, Rx and Tx Endpoints */
	Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT,
		                       ENDPOINT_DIR_IN, CDC_NOTIFICATION_EPSIZE,
	                           ENDPOINT_BANK_SINGLE);

	Endpoint_ConfigureEndpoint(CDC_TX_EPNUM, EP_TYPE_BULK,
 2a2:	24 e0       	ldi	r18, 0x04	; 4
 2a4:	41 e8       	ldi	r20, 0x81	; 129
 2a6:	60 e1       	ldi	r22, 0x10	; 16
 2a8:	70 e0       	ldi	r23, 0x00	; 0
 2aa:	83 e0       	ldi	r24, 0x03	; 3
 2ac:	c9 d2       	rcall	.+1426   	; 0x840 <Endpoint_ConfigureEndpoint_P>
		                       ENDPOINT_DIR_IN, CDC_TXRX_EPSIZE,
	                           ENDPOINT_BANK_DOUBLE);

	Endpoint_ConfigureEndpoint(CDC_RX_EPNUM, EP_TYPE_BULK,
 2ae:	24 e0       	ldi	r18, 0x04	; 4
 2b0:	40 e8       	ldi	r20, 0x80	; 128
 2b2:	60 e1       	ldi	r22, 0x10	; 16
 2b4:	70 e0       	ldi	r23, 0x00	; 0
 2b6:	84 e0       	ldi	r24, 0x04	; 4
 2b8:	c3 d2       	rcall	.+1414   	; 0x840 <Endpoint_ConfigureEndpoint_P>
		                       ENDPOINT_DIR_OUT, CDC_TXRX_EPSIZE,
	                           ENDPOINT_BANK_DOUBLE);

	/* Start CDC task */
	Scheduler_SetTaskMode(CDC_Task, TASK_RUN);	
 2ba:	61 e0       	ldi	r22, 0x01	; 1
 2bc:	8b ed       	ldi	r24, 0xDB	; 219
 2be:	90 e0       	ldi	r25, 0x00	; 0
 2c0:	1f d2       	rcall	.+1086   	; 0x700 <Scheduler_SetTaskMode>
	Scheduler_SetTaskMode(PCLink_Task, TASK_RUN);
 2c2:	61 e0       	ldi	r22, 0x01	; 1
 2c4:	8a e0       	ldi	r24, 0x0A	; 10
 2c6:	92 e0       	ldi	r25, 0x02	; 2
 2c8:	1b d2       	rcall	.+1078   	; 0x700 <Scheduler_SetTaskMode>
	PORTD &= ~(1<<PD4); /* Turn off LED */
 2ca:	5c 98       	cbi	0x0b, 4	; 11
 2cc:	08 95       	ret

000002ce <Event_USB_UnhandledControlPacket>:
}

EVENT_HANDLER(USB_UnhandledControlPacket)
{
 2ce:	98 2f       	mov	r25, r24
	uint8_t* LineCodingData = (uint8_t*)&LineCoding;
 2d0:	e4 e1       	ldi	r30, 0x14	; 20
 2d2:	f1 e0       	ldi	r31, 0x01	; 1
			/** Discards two bytes from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline void Endpoint_Ignore_Word(void)
			{
				uint8_t Dummy;
				
				Dummy = UEDATX;
 2d4:	80 91 f1 00 	lds	r24, 0x00F1
				Dummy = UEDATX;
 2d8:	80 91 f1 00 	lds	r24, 0x00F1

	Endpoint_Ignore_Word();

	/* Process CDC specific control requests */
	switch (Request)
 2dc:	91 32       	cpi	r25, 0x21	; 33
 2de:	39 f0       	breq	.+14     	; 0x2ee <Event_USB_UnhandledControlPacket+0x20>
 2e0:	92 32       	cpi	r25, 0x22	; 34
 2e2:	09 f4       	brne	.+2      	; 0x2e6 <Event_USB_UnhandledControlPacket+0x18>
 2e4:	47 c0       	rjmp	.+142    	; 0x374 <__stack+0x75>
 2e6:	90 32       	cpi	r25, 0x20	; 32
 2e8:	09 f0       	breq	.+2      	; 0x2ec <Event_USB_UnhandledControlPacket+0x1e>
 2ea:	54 c0       	rjmp	.+168    	; 0x394 <__stack+0x95>
 2ec:	22 c0       	rjmp	.+68     	; 0x332 <__stack+0x33>
	{
		case GET_LINE_CODING:
			if (RequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
 2ee:	61 3a       	cpi	r22, 0xA1	; 161
 2f0:	09 f0       	breq	.+2      	; 0x2f4 <Event_USB_UnhandledControlPacket+0x26>
 2f2:	50 c0       	rjmp	.+160    	; 0x394 <__stack+0x95>
			{
				Endpoint_ClearSetupReceived();
 2f4:	80 91 e8 00 	lds	r24, 0x00E8
 2f8:	87 7f       	andi	r24, 0xF7	; 247
 2fa:	80 93 e8 00 	sts	0x00E8, r24

				for (uint8_t i = 0; i < sizeof(LineCoding); i++)
				  Endpoint_Write_Byte(*(LineCodingData++));	
 2fe:	81 91       	ld	r24, Z+
			}

			/** Writes one byte from the currently selected endpoint's bank, for IN direction endpoints. */
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 300:	80 93 f1 00 	sts	0x00F1, r24
		case GET_LINE_CODING:
			if (RequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
			{
				Endpoint_ClearSetupReceived();

				for (uint8_t i = 0; i < sizeof(LineCoding); i++)
 304:	81 e0       	ldi	r24, 0x01	; 1
 306:	eb 31       	cpi	r30, 0x1B	; 27
 308:	f8 07       	cpc	r31, r24
 30a:	c9 f7       	brne	.-14     	; 0x2fe <Event_USB_UnhandledControlPacket+0x30>
				  Endpoint_Write_Byte(*(LineCodingData++));	
				
				Endpoint_ClearSetupIN();
 30c:	80 91 e8 00 	lds	r24, 0x00E8
 310:	8e 7f       	andi	r24, 0xFE	; 254
 312:	80 93 e8 00 	sts	0x00E8, r24
				while (!(Endpoint_IsSetupINReady()));
 316:	80 91 e8 00 	lds	r24, 0x00E8
 31a:	80 ff       	sbrs	r24, 0
 31c:	fc cf       	rjmp	.-8      	; 0x316 <__stack+0x17>
				
				while (!(Endpoint_IsSetupOUTReceived()));
 31e:	80 91 e8 00 	lds	r24, 0x00E8
 322:	82 ff       	sbrs	r24, 2
 324:	fc cf       	rjmp	.-8      	; 0x31e <__stack+0x1f>
				Endpoint_ClearSetupOUT();
 326:	80 91 e8 00 	lds	r24, 0x00E8
 32a:	8b 7f       	andi	r24, 0xFB	; 251
 32c:	80 93 e8 00 	sts	0x00E8, r24
 330:	08 95       	ret
			}
			
			break;
		case SET_LINE_CODING:
			if (RequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
 332:	61 32       	cpi	r22, 0x21	; 33
 334:	79 f5       	brne	.+94     	; 0x394 <__stack+0x95>
			{
				Endpoint_ClearSetupReceived();
 336:	80 91 e8 00 	lds	r24, 0x00E8
 33a:	87 7f       	andi	r24, 0xF7	; 247
 33c:	80 93 e8 00 	sts	0x00E8, r24

				while (!(Endpoint_IsSetupOUTReceived()));
 340:	80 91 e8 00 	lds	r24, 0x00E8
 344:	82 ff       	sbrs	r24, 2
 346:	fc cf       	rjmp	.-8      	; 0x340 <__stack+0x41>
		/* Inline Functions: */
			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 348:	80 91 f1 00 	lds	r24, 0x00F1

				for (uint8_t i = 0; i < sizeof(LineCoding); i++)
				  *(LineCodingData++) = Endpoint_Read_Byte();
 34c:	81 93       	st	Z+, r24
			{
				Endpoint_ClearSetupReceived();

				while (!(Endpoint_IsSetupOUTReceived()));

				for (uint8_t i = 0; i < sizeof(LineCoding); i++)
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	eb 31       	cpi	r30, 0x1B	; 27
 352:	f8 07       	cpc	r31, r24
 354:	c9 f7       	brne	.-14     	; 0x348 <__stack+0x49>
				  *(LineCodingData++) = Endpoint_Read_Byte();

				Endpoint_ClearSetupOUT();
 356:	80 91 e8 00 	lds	r24, 0x00E8
 35a:	8b 7f       	andi	r24, 0xFB	; 251
 35c:	80 93 e8 00 	sts	0x00E8, r24

				Endpoint_ClearSetupIN();
 360:	80 91 e8 00 	lds	r24, 0x00E8
 364:	8e 7f       	andi	r24, 0xFE	; 254
 366:	80 93 e8 00 	sts	0x00E8, r24
				while (!(Endpoint_IsSetupINReady()));
 36a:	80 91 e8 00 	lds	r24, 0x00E8
 36e:	80 fd       	sbrc	r24, 0
 370:	11 c0       	rjmp	.+34     	; 0x394 <__stack+0x95>
 372:	fb cf       	rjmp	.-10     	; 0x36a <__stack+0x6b>
			}
	
			break;
		case SET_CONTROL_LINE_STATE:
			if (RequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
 374:	61 32       	cpi	r22, 0x21	; 33
 376:	71 f4       	brne	.+28     	; 0x394 <__stack+0x95>
			{
				Endpoint_ClearSetupReceived();
 378:	80 91 e8 00 	lds	r24, 0x00E8
 37c:	87 7f       	andi	r24, 0xF7	; 247
 37e:	80 93 e8 00 	sts	0x00E8, r24
				
				Endpoint_ClearSetupIN();
 382:	80 91 e8 00 	lds	r24, 0x00E8
 386:	8e 7f       	andi	r24, 0xFE	; 254
 388:	80 93 e8 00 	sts	0x00E8, r24
				while (!(Endpoint_IsSetupINReady()));
 38c:	80 91 e8 00 	lds	r24, 0x00E8
 390:	80 ff       	sbrs	r24, 0
 392:	fc cf       	rjmp	.-8      	; 0x38c <__stack+0x8d>
 394:	08 95       	ret

00000396 <main>:
	/* Scheduler test - increment scheduler tick counter once each millisecond */
	Scheduler_TickCounter++;
}
		
int main(void)
{
 396:	cf ef       	ldi	r28, 0xFF	; 255
 398:	d2 e0       	ldi	r29, 0x02	; 2
 39a:	de bf       	out	0x3e, r29	; 62
 39c:	cd bf       	out	0x3d, r28	; 61
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
 39e:	84 b7       	in	r24, 0x34	; 52
 3a0:	87 7f       	andi	r24, 0xF7	; 247
 3a2:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
 3a4:	88 e1       	ldi	r24, 0x18	; 24
 3a6:	0f b6       	in	r0, 0x3f	; 63
 3a8:	f8 94       	cli
 3aa:	80 93 60 00 	sts	0x0060, r24
 3ae:	10 92 60 00 	sts	0x0060, r1
 3b2:	0f be       	out	0x3f, r0	; 63
			 * \param PrescalerMask   The mask of the new prescaler setting for CLKPR
			 */
			static inline void SetSystemClockPrescaler(uint8_t PrescalerMask)
			{
					uint8_t tmp = _BV(CLKPCE);
					__asm__ __volatile__ (
 3b4:	90 e8       	ldi	r25, 0x80	; 128
 3b6:	80 e0       	ldi	r24, 0x00	; 0
 3b8:	0f b6       	in	r0, 0x3f	; 63
 3ba:	f8 94       	cli
 3bc:	90 93 61 00 	sts	0x0061, r25
 3c0:	80 93 61 00 	sts	0x0061, r24
 3c4:	0f be       	out	0x3f, r0	; 63
}
	
void Hardware_Init(void)
{
	/* Output pin for the LED and sensor heffect ect */
	DDRD |= ((1<<PD4) | (1<<PD1));
 3c6:	8a b1       	in	r24, 0x0a	; 10
 3c8:	82 61       	ori	r24, 0x12	; 18
 3ca:	8a b9       	out	0x0a, r24	; 10
	
	/* Millisecond timer initialization, with output compare interrupt enabled */
	OCR0A  = 0x7D;
 3cc:	8d e7       	ldi	r24, 0x7D	; 125
 3ce:	87 bd       	out	0x27, r24	; 39
	TCCR0A = (1 << WGM01);
 3d0:	92 e0       	ldi	r25, 0x02	; 2
 3d2:	94 bd       	out	0x24, r25	; 36
	TCCR0B = ((1 << CS01) | (1 << CS00));
 3d4:	83 e0       	ldi	r24, 0x03	; 3
 3d6:	85 bd       	out	0x25, r24	; 37
	TIMSK0 = (1 << OCIE0A);
 3d8:	90 93 6e 00 	sts	0x006E, r25

	/* Hardware Initialization */
	Hardware_Init();
	
	/* Ringbuffer Initialization */
	Buffer_Initialize(&Rx_Buffer);
 3dc:	86 e3       	ldi	r24, 0x36	; 54
 3de:	91 e0       	ldi	r25, 0x01	; 1
 3e0:	25 d1       	rcall	.+586    	; 0x62c <Buffer_Initialize>
	Buffer_Initialize(&Tx_Buffer);
 3e2:	81 e2       	ldi	r24, 0x21	; 33
 3e4:	91 e0       	ldi	r25, 0x01	; 1
 3e6:	22 d1       	rcall	.+580    	; 0x62c <Buffer_Initialize>
			#define MAX_DELAYCTR_COUNT                0xFFFF

		/* Inline Functions: */
			static inline void Scheduler_InitScheduler(const uint8_t TotalTasks)
			{
				Scheduler_TotalTasks = TotalTasks;
 3e8:	15 e0       	ldi	r17, 0x05	; 5
 3ea:	10 93 4c 01 	sts	0x014C, r17

	/* Initialize Scheduler so that it can be used */
	Scheduler_Init();

	/* Initialize USB Subsystem */
	USB_Init();
 3ee:	17 d2       	rcall	.+1070   	; 0x81e <USB_Init>
 3f0:	10 93 4c 01 	sts	0x014C, r17
 3f4:	c0 e0       	ldi	r28, 0x00	; 0
 3f6:	d1 e0       	ldi	r29, 0x01	; 1
 3f8:	07 c0       	rjmp	.+14     	; 0x408 <main+0x72>
				{
					TaskEntry_t* CurrTask = &Scheduler_TaskList[0];
					
					while (CurrTask != &Scheduler_TaskList[TotalTasks])
					{
						if (CurrTask->TaskStatus == TASK_RUN)
 3fa:	8a 81       	ldd	r24, Y+2	; 0x02
 3fc:	88 23       	and	r24, r24
 3fe:	19 f0       	breq	.+6      	; 0x406 <main+0x70>
						  CurrTask->Task();
 400:	e8 81       	ld	r30, Y
 402:	f9 81       	ldd	r31, Y+1	; 0x01
 404:	09 95       	icall

						CurrTask++;
 406:	24 96       	adiw	r28, 0x04	; 4

				for (;;)
				{
					TaskEntry_t* CurrTask = &Scheduler_TaskList[0];
					
					while (CurrTask != &Scheduler_TaskList[TotalTasks])
 408:	81 e0       	ldi	r24, 0x01	; 1
 40a:	c4 31       	cpi	r28, 0x14	; 20
 40c:	d8 07       	cpc	r29, r24
 40e:	a9 f7       	brne	.-22     	; 0x3fa <main+0x64>
 410:	64 97       	sbiw	r28, 0x14	; 20
 412:	fa cf       	rjmp	.-12     	; 0x408 <main+0x72>

00000414 <PCLink_Task>:
		}
	}
}

TASK(PCLink_Task)
{
 414:	cf 93       	push	r28
 416:	df 93       	push	r29
	static unsigned char
		ucCommand = 0,
		ucNumberDataBytes = 0;
	
	if (Rx_Buffer.Elements)
 418:	80 91 4a 01 	lds	r24, 0x014A
 41c:	88 23       	and	r24, r24
 41e:	09 f4       	brne	.+2      	; 0x422 <PCLink_Task+0xe>
 420:	c5 c0       	rjmp	.+394    	; 0x5ac <PCLink_Task+0x198>
	{
		if (ucNumberDataBytes == 0)
 422:	80 91 1c 01 	lds	r24, 0x011C
 426:	88 23       	and	r24, r24
 428:	29 f4       	brne	.+10     	; 0x434 <PCLink_Task+0x20>
			ucCommand = Buffer_GetElement (&Rx_Buffer);
 42a:	86 e3       	ldi	r24, 0x36	; 54
 42c:	91 e0       	ldi	r25, 0x01	; 1
 42e:	08 d1       	rcall	.+528    	; 0x640 <Buffer_GetElement>
 430:	80 93 1d 01 	sts	0x011D, r24

		switch (ucCommand)
 434:	90 91 1d 01 	lds	r25, 0x011D
 438:	92 30       	cpi	r25, 0x02	; 2
 43a:	d1 f0       	breq	.+52     	; 0x470 <PCLink_Task+0x5c>
 43c:	93 30       	cpi	r25, 0x03	; 3
 43e:	20 f4       	brcc	.+8      	; 0x448 <PCLink_Task+0x34>
 440:	91 30       	cpi	r25, 0x01	; 1
 442:	09 f0       	breq	.+2      	; 0x446 <PCLink_Task+0x32>
 444:	b3 c0       	rjmp	.+358    	; 0x5ac <PCLink_Task+0x198>
 446:	07 c0       	rjmp	.+14     	; 0x456 <PCLink_Task+0x42>
 448:	93 30       	cpi	r25, 0x03	; 3
 44a:	09 f4       	brne	.+2      	; 0x44e <PCLink_Task+0x3a>
 44c:	3e c0       	rjmp	.+124    	; 0x4ca <PCLink_Task+0xb6>
 44e:	94 30       	cpi	r25, 0x04	; 4
 450:	09 f0       	breq	.+2      	; 0x454 <PCLink_Task+0x40>
 452:	ac c0       	rjmp	.+344    	; 0x5ac <PCLink_Task+0x198>
 454:	7e c0       	rjmp	.+252    	; 0x552 <PCLink_Task+0x13e>
		{			
			case DUMMY:
			/* First byte of this command, fill the NumberDataBytes */			
			if (ucNumberDataBytes <= 0)
 456:	80 91 1c 01 	lds	r24, 0x011C
 45a:	88 23       	and	r24, r24
 45c:	11 f4       	brne	.+4      	; 0x462 <PCLink_Task+0x4e>
			ucNumberDataBytes = 1;
 45e:	90 93 1c 01 	sts	0x011C, r25
				
			if (Tx_Buffer.Elements < BUFF_STATICSIZE)
 462:	80 91 35 01 	lds	r24, 0x0135
 466:	80 31       	cpi	r24, 0x10	; 16
 468:	08 f0       	brcs	.+2      	; 0x46c <PCLink_Task+0x58>
 46a:	a0 c0       	rjmp	.+320    	; 0x5ac <PCLink_Task+0x198>
			{
				Buffer_StoreElement (&Tx_Buffer, ucCommand);
 46c:	61 e0       	ldi	r22, 0x01	; 1
 46e:	83 c0       	rjmp	.+262    	; 0x576 <PCLink_Task+0x162>
			}		
			break;
				
			case RETRIEVE_FIRMWARE_VERSION:
			/* First byte of this command, fill the NumberDataBytes */			
			if (ucNumberDataBytes <= 0)
 470:	80 91 1c 01 	lds	r24, 0x011C
 474:	88 23       	and	r24, r24
 476:	e9 f4       	brne	.+58     	; 0x4b2 <PCLink_Task+0x9e>
					ucNumberDataBytes = 4;
 478:	84 e0       	ldi	r24, 0x04	; 4
 47a:	80 93 1c 01 	sts	0x011C, r24
 47e:	19 c0       	rjmp	.+50     	; 0x4b2 <PCLink_Task+0x9e>
					
			while (Tx_Buffer.Elements < BUFF_STATICSIZE && ucNumberDataBytes > 0)
			{
				switch (ucNumberDataBytes)
 480:	82 30       	cpi	r24, 0x02	; 2
 482:	61 f0       	breq	.+24     	; 0x49c <PCLink_Task+0x88>
 484:	83 30       	cpi	r24, 0x03	; 3
 486:	18 f4       	brcc	.+6      	; 0x48e <PCLink_Task+0x7a>
 488:	81 30       	cpi	r24, 0x01	; 1
 48a:	69 f4       	brne	.+26     	; 0x4a6 <PCLink_Task+0x92>
 48c:	09 c0       	rjmp	.+18     	; 0x4a0 <PCLink_Task+0x8c>
 48e:	83 30       	cpi	r24, 0x03	; 3
 490:	39 f0       	breq	.+14     	; 0x4a0 <PCLink_Task+0x8c>
 492:	84 30       	cpi	r24, 0x04	; 4
 494:	41 f4       	brne	.+16     	; 0x4a6 <PCLink_Task+0x92>
				{
					case 4:
					Buffer_StoreElement (&Tx_Buffer, ucCommand);
 496:	60 91 1d 01 	lds	r22, 0x011D
 49a:	03 c0       	rjmp	.+6      	; 0x4a2 <PCLink_Task+0x8e>
					case 3:
					Buffer_StoreElement (&Tx_Buffer, BICYCLELEDPOV_VERSION_MAJOR);
					break;
						
					case 2:
					Buffer_StoreElement (&Tx_Buffer, BICYCLELEDPOV_VERSION_MINOR);
 49c:	61 e0       	ldi	r22, 0x01	; 1
 49e:	01 c0       	rjmp	.+2      	; 0x4a2 <PCLink_Task+0x8e>
					break;

					case 1:
					Buffer_StoreElement (&Tx_Buffer, BICYCLELEDPOV_VERSION_REVISION);
 4a0:	60 e0       	ldi	r22, 0x00	; 0
 4a2:	ce 01       	movw	r24, r28
 4a4:	fb d0       	rcall	.+502    	; 0x69c <Buffer_StoreElement>
							
					default:
					break;
				}		
							
			ucNumberDataBytes--;
 4a6:	80 91 1c 01 	lds	r24, 0x011C
 4aa:	81 50       	subi	r24, 0x01	; 1
 4ac:	80 93 1c 01 	sts	0x011C, r24
 4b0:	02 c0       	rjmp	.+4      	; 0x4b6 <PCLink_Task+0xa2>
 4b2:	c1 e2       	ldi	r28, 0x21	; 33
 4b4:	d1 e0       	ldi	r29, 0x01	; 1
			case RETRIEVE_FIRMWARE_VERSION:
			/* First byte of this command, fill the NumberDataBytes */			
			if (ucNumberDataBytes <= 0)
					ucNumberDataBytes = 4;
					
			while (Tx_Buffer.Elements < BUFF_STATICSIZE && ucNumberDataBytes > 0)
 4b6:	80 91 35 01 	lds	r24, 0x0135
 4ba:	80 31       	cpi	r24, 0x10	; 16
 4bc:	08 f0       	brcs	.+2      	; 0x4c0 <PCLink_Task+0xac>
 4be:	76 c0       	rjmp	.+236    	; 0x5ac <PCLink_Task+0x198>
 4c0:	80 91 1c 01 	lds	r24, 0x011C
 4c4:	88 23       	and	r24, r24
 4c6:	e1 f6       	brne	.-72     	; 0x480 <PCLink_Task+0x6c>
 4c8:	71 c0       	rjmp	.+226    	; 0x5ac <PCLink_Task+0x198>
			}
			break;
							
			case TEST_LEDS:
			/* First byte of this command, fill the NumberDataBytes */
			if (ucNumberDataBytes <= 0)
 4ca:	80 91 1c 01 	lds	r24, 0x011C
 4ce:	88 23       	and	r24, r24
 4d0:	19 f4       	brne	.+6      	; 0x4d8 <PCLink_Task+0xc4>
				ucNumberDataBytes = 5;
 4d2:	85 e0       	ldi	r24, 0x05	; 5
 4d4:	80 93 1c 01 	sts	0x011C, r24
				
			if (ucNumberDataBytes == 5 && Tx_Buffer.Elements < BUFF_STATICSIZE)
 4d8:	80 91 1c 01 	lds	r24, 0x011C
 4dc:	85 30       	cpi	r24, 0x05	; 5
 4de:	71 f5       	brne	.+92     	; 0x53c <PCLink_Task+0x128>
 4e0:	80 91 35 01 	lds	r24, 0x0135
 4e4:	80 31       	cpi	r24, 0x10	; 16
 4e6:	50 f5       	brcc	.+84     	; 0x53c <PCLink_Task+0x128>
			{
				/* Send back the number of the command */
				Buffer_StoreElement (&Tx_Buffer, ucCommand);
 4e8:	63 e0       	ldi	r22, 0x03	; 3
 4ea:	81 e2       	ldi	r24, 0x21	; 33
 4ec:	91 e0       	ldi	r25, 0x01	; 1
 4ee:	d6 d0       	rcall	.+428    	; 0x69c <Buffer_StoreElement>
				ucNumberDataBytes--;
 4f0:	80 91 1c 01 	lds	r24, 0x011C
 4f4:	81 50       	subi	r24, 0x01	; 1
 4f6:	80 93 1c 01 	sts	0x011C, r24
 4fa:	20 c0       	rjmp	.+64     	; 0x53c <PCLink_Task+0x128>
			}
				
			/* Send the 4 bytes to LEDs drivers on the next 4 cases */
			while (Rx_Buffer.Elements && ucNumberDataBytes > 0)
			{	
				switch (ucNumberDataBytes)
 4fc:	82 30       	cpi	r24, 0x02	; 2
 4fe:	49 f0       	breq	.+18     	; 0x512 <PCLink_Task+0xfe>
 500:	83 30       	cpi	r24, 0x03	; 3
 502:	18 f4       	brcc	.+6      	; 0x50a <PCLink_Task+0xf6>
 504:	81 30       	cpi	r24, 0x01	; 1
 506:	e1 f4       	brne	.+56     	; 0x540 <PCLink_Task+0x12c>
 508:	0b c0       	rjmp	.+22     	; 0x520 <PCLink_Task+0x10c>
 50a:	83 30       	cpi	r24, 0x03	; 3
 50c:	11 f0       	breq	.+4      	; 0x512 <PCLink_Task+0xfe>
 50e:	84 30       	cpi	r24, 0x04	; 4
 510:	b9 f4       	brne	.+46     	; 0x540 <PCLink_Task+0x12c>
					SPI_Disable();
					ucNumberDataBytes--;
					break;
					
					case 2:
					SPI_MasterInit(DATA_ORDER_MSB);
 512:	80 e0       	ldi	r24, 0x00	; 0
 514:	18 d4       	rcall	.+2096   	; 0xd46 <SPI_MasterInit>
					SPI_MasterTransmit (Buffer_GetElement (&Rx_Buffer));
 516:	ce 01       	movw	r24, r28
 518:	93 d0       	rcall	.+294    	; 0x640 <Buffer_GetElement>
 51a:	2f d4       	rcall	.+2142   	; 0xd7a <SPI_MasterTransmit>
					SPI_Disable();
 51c:	25 d4       	rcall	.+2122   	; 0xd68 <SPI_Disable>
 51e:	08 c0       	rjmp	.+16     	; 0x530 <PCLink_Task+0x11c>
					ucNumberDataBytes--;
					break;
					
					case 1:
					SPI_MasterInit(DATA_ORDER_MSB);
 520:	80 e0       	ldi	r24, 0x00	; 0
 522:	11 d4       	rcall	.+2082   	; 0xd46 <SPI_MasterInit>
					SPI_MasterTransmit (Buffer_GetElement (&Rx_Buffer));
 524:	ce 01       	movw	r24, r28
 526:	8c d0       	rcall	.+280    	; 0x640 <Buffer_GetElement>
 528:	28 d4       	rcall	.+2128   	; 0xd7a <SPI_MasterTransmit>
					SPI_Disable();
 52a:	1e d4       	rcall	.+2108   	; 0xd68 <SPI_Disable>
void ClockDataLatches(unsigned char SideDataLatches)
{
	switch (SideDataLatches)
	{
		case LEFT_SIDE_DATA_LATCHES:
		PORTB |= (1<<PB4);
 52c:	2c 9a       	sbi	0x05, 4	; 5
		PORTB &= ~(1<<PB4);
 52e:	2c 98       	cbi	0x05, 4	; 5
					case 1:
					SPI_MasterInit(DATA_ORDER_MSB);
					SPI_MasterTransmit (Buffer_GetElement (&Rx_Buffer));
					SPI_Disable();
					ClockDataLatches (LEFT_SIDE_DATA_LATCHES);
					ucNumberDataBytes--;
 530:	80 91 1c 01 	lds	r24, 0x011C
 534:	81 50       	subi	r24, 0x01	; 1
 536:	80 93 1c 01 	sts	0x011C, r24
 53a:	02 c0       	rjmp	.+4      	; 0x540 <PCLink_Task+0x12c>
 53c:	c6 e3       	ldi	r28, 0x36	; 54
 53e:	d1 e0       	ldi	r29, 0x01	; 1
				Buffer_StoreElement (&Tx_Buffer, ucCommand);
				ucNumberDataBytes--;
			}
				
			/* Send the 4 bytes to LEDs drivers on the next 4 cases */
			while (Rx_Buffer.Elements && ucNumberDataBytes > 0)
 540:	80 91 4a 01 	lds	r24, 0x014A
 544:	88 23       	and	r24, r24
 546:	91 f1       	breq	.+100    	; 0x5ac <PCLink_Task+0x198>
 548:	80 91 1c 01 	lds	r24, 0x011C
 54c:	88 23       	and	r24, r24
 54e:	b1 f6       	brne	.-84     	; 0x4fc <PCLink_Task+0xe8>
 550:	2d c0       	rjmp	.+90     	; 0x5ac <PCLink_Task+0x198>
			}
			break;			
					
			case TEST_SENSOR_HALL_EFFECT:					
			/* First byte of this command, fill the NumberDataBytes */
			if (ucNumberDataBytes <= 0)
 552:	80 91 1c 01 	lds	r24, 0x011C
 556:	88 23       	and	r24, r24
 558:	19 f4       	brne	.+6      	; 0x560 <PCLink_Task+0x14c>
				ucNumberDataBytes = 2;		
 55a:	82 e0       	ldi	r24, 0x02	; 2
 55c:	80 93 1c 01 	sts	0x011C, r24
			
			switch (ucNumberDataBytes)
 560:	80 91 1c 01 	lds	r24, 0x011C
 564:	81 30       	cpi	r24, 0x01	; 1
 566:	59 f0       	breq	.+22     	; 0x57e <PCLink_Task+0x16a>
 568:	82 30       	cpi	r24, 0x02	; 2
 56a:	01 f5       	brne	.+64     	; 0x5ac <PCLink_Task+0x198>
			{
				case 2: /* Send back the number of the command */
				if (Tx_Buffer.Elements < BUFF_STATICSIZE)
 56c:	80 91 35 01 	lds	r24, 0x0135
 570:	80 31       	cpi	r24, 0x10	; 16
 572:	e0 f4       	brcc	.+56     	; 0x5ac <PCLink_Task+0x198>
				{
					Buffer_StoreElement (&Tx_Buffer, ucCommand);
 574:	64 e0       	ldi	r22, 0x04	; 4
 576:	81 e2       	ldi	r24, 0x21	; 33
 578:	91 e0       	ldi	r25, 0x01	; 1
 57a:	90 d0       	rcall	.+288    	; 0x69c <Buffer_StoreElement>
 57c:	12 c0       	rjmp	.+36     	; 0x5a2 <PCLink_Task+0x18e>
					ucNumberDataBytes--;
				}
				break;					

			 	case 1: /* See If we should turn on or off the test */						
				if (Buffer_GetElement (&Rx_Buffer) == 1)
 57e:	86 e3       	ldi	r24, 0x36	; 54
 580:	91 e0       	ldi	r25, 0x01	; 1
 582:	5e d0       	rcall	.+188    	; 0x640 <Buffer_GetElement>
 584:	81 30       	cpi	r24, 0x01	; 1
 586:	31 f4       	brne	.+12     	; 0x594 <PCLink_Task+0x180>
				{
					Scheduler_SetTaskMode(TestSensorHallEffect_Task, TASK_RUN);
 588:	61 e0       	ldi	r22, 0x01	; 1
 58a:	85 ed       	ldi	r24, 0xD5	; 213
 58c:	90 e0       	ldi	r25, 0x00	; 0
 58e:	b8 d0       	rcall	.+368    	; 0x700 <Scheduler_SetTaskMode>
					
					/* Turn on the source voltage for sensor hall effect */
					PORTD |= (1<<PD1);
 590:	59 9a       	sbi	0x0b, 1	; 11
 592:	07 c0       	rjmp	.+14     	; 0x5a2 <PCLink_Task+0x18e>
				}
				
				else
				{
					Scheduler_SetTaskMode(TestSensorHallEffect_Task, TASK_STOP);
 594:	60 e0       	ldi	r22, 0x00	; 0
 596:	85 ed       	ldi	r24, 0xD5	; 213
 598:	90 e0       	ldi	r25, 0x00	; 0
 59a:	b2 d0       	rcall	.+356    	; 0x700 <Scheduler_SetTaskMode>
					
					/* Turn off LED and source voltage for sensor hall effect */
					PORTD &= ~((1<<PD4) | (1<<PD1));
 59c:	8b b1       	in	r24, 0x0b	; 11
 59e:	8d 7e       	andi	r24, 0xED	; 237
 5a0:	8b b9       	out	0x0b, r24	; 11
				}	
				
				ucNumberDataBytes--;
 5a2:	80 91 1c 01 	lds	r24, 0x011C
 5a6:	81 50       	subi	r24, 0x01	; 1
 5a8:	80 93 1c 01 	sts	0x011C, r24
 5ac:	df 91       	pop	r29
 5ae:	cf 91       	pop	r28
 5b0:	08 95       	ret

000005b2 <USB_GetDescriptor>:
	UnicodeString:          L"000000000000"
};

bool USB_GetDescriptor(const uint8_t Type, const uint8_t Index, const uint16_t LanguageID,
                       void** const DescriptorAddress, uint16_t* const DescriptorSize)
{
 5b2:	0f 93       	push	r16
 5b4:	1f 93       	push	r17
 5b6:	cf 93       	push	r28
 5b8:	df 93       	push	r29
 5ba:	d9 01       	movw	r26, r18
 5bc:	e8 01       	movw	r28, r16
	void*    Address = NULL;
	uint16_t Size    = 0;

	switch (Type)
 5be:	82 30       	cpi	r24, 0x02	; 2
 5c0:	31 f1       	breq	.+76     	; 0x60e <USB_GetDescriptor+0x5c>
 5c2:	83 30       	cpi	r24, 0x03	; 3
 5c4:	39 f0       	breq	.+14     	; 0x5d4 <USB_GetDescriptor+0x22>
 5c6:	81 30       	cpi	r24, 0x01	; 1
 5c8:	f9 f4       	brne	.+62     	; 0x608 <USB_GetDescriptor+0x56>
 5ca:	82 e1       	ldi	r24, 0x12	; 18
 5cc:	90 e0       	ldi	r25, 0x00	; 0
 5ce:	e4 e7       	ldi	r30, 0x74	; 116
 5d0:	f0 e0       	ldi	r31, 0x00	; 0
 5d2:	21 c0       	rjmp	.+66     	; 0x616 <USB_GetDescriptor+0x64>
		case DTYPE_Configuration:
			Address = DESCRIPTOR_ADDRESS(ConfigurationDescriptor);
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (Index)
 5d4:	61 30       	cpi	r22, 0x01	; 1
 5d6:	59 f0       	breq	.+22     	; 0x5ee <USB_GetDescriptor+0x3c>
 5d8:	61 30       	cpi	r22, 0x01	; 1
 5da:	28 f0       	brcs	.+10     	; 0x5e6 <USB_GetDescriptor+0x34>
 5dc:	62 30       	cpi	r22, 0x02	; 2
 5de:	59 f0       	breq	.+22     	; 0x5f6 <USB_GetDescriptor+0x44>
 5e0:	63 30       	cpi	r22, 0x03	; 3
 5e2:	91 f4       	brne	.+36     	; 0x608 <USB_GetDescriptor+0x56>
 5e4:	0c c0       	rjmp	.+24     	; 0x5fe <USB_GetDescriptor+0x4c>
			{
				case 0x00:
					Address = DESCRIPTOR_ADDRESS(LanguageString);
					Size    = pgm_read_byte(&LanguageString.Header.Size);
 5e6:	e9 ec       	ldi	r30, 0xC9	; 201
 5e8:	f0 e0       	ldi	r31, 0x00	; 0
 5ea:	84 91       	lpm	r24, Z
 5ec:	0b c0       	rjmp	.+22     	; 0x604 <USB_GetDescriptor+0x52>
					break;
				case 0x01:
					Address = DESCRIPTOR_ADDRESS(ManafacturerString);
					Size    = pgm_read_byte(&ManafacturerString.Header.Size);
 5ee:	ed ec       	ldi	r30, 0xCD	; 205
 5f0:	f0 e0       	ldi	r31, 0x00	; 0
 5f2:	84 91       	lpm	r24, Z
 5f4:	07 c0       	rjmp	.+14     	; 0x604 <USB_GetDescriptor+0x52>
					break;
				case 0x02:
					Address = DESCRIPTOR_ADDRESS(ProductString);
					Size    = pgm_read_byte(&ProductString.Header.Size);
 5f6:	e1 e0       	ldi	r30, 0x01	; 1
 5f8:	f1 e0       	ldi	r31, 0x01	; 1
 5fa:	84 91       	lpm	r24, Z
 5fc:	03 c0       	rjmp	.+6      	; 0x604 <USB_GetDescriptor+0x52>
					break;
				case 0x03:
					Address = DESCRIPTOR_ADDRESS(SerialNumberString);
					Size    = pgm_read_byte(&SerialNumberString.Header.Size);
 5fe:	e3 e2       	ldi	r30, 0x23	; 35
 600:	f1 e0       	ldi	r31, 0x01	; 1
 602:	84 91       	lpm	r24, Z
 604:	99 27       	eor	r25, r25
 606:	07 c0       	rjmp	.+14     	; 0x616 <USB_GetDescriptor+0x64>
 608:	80 e0       	ldi	r24, 0x00	; 0
 60a:	90 e0       	ldi	r25, 0x00	; 0
 60c:	0a c0       	rjmp	.+20     	; 0x622 <USB_GetDescriptor+0x70>
 60e:	83 e4       	ldi	r24, 0x43	; 67
 610:	90 e0       	ldi	r25, 0x00	; 0
 612:	e6 e8       	ldi	r30, 0x86	; 134
 614:	f0 e0       	ldi	r31, 0x00	; 0
			break;
	}
	
	if (Address != NULL)
	{
		*DescriptorAddress = Address;
 616:	ed 93       	st	X+, r30
 618:	fc 93       	st	X, r31
		*DescriptorSize    = Size;
 61a:	99 83       	std	Y+1, r25	; 0x01
 61c:	88 83       	st	Y, r24
 61e:	81 e0       	ldi	r24, 0x01	; 1
 620:	90 e0       	ldi	r25, 0x00	; 0
 622:	df 91       	pop	r29
 624:	cf 91       	pop	r28
 626:	1f 91       	pop	r17
 628:	0f 91       	pop	r16
 62a:	08 95       	ret

0000062c <Buffer_Initialize>:
*/

#include "RingBuff.h"

void Buffer_Initialize(RingBuff_t* Buffer)
{
 62c:	fc 01       	movw	r30, r24
	BUFF_ATOMIC_BLOCK
 62e:	8f b7       	in	r24, 0x3f	; 63
				return 1;
			}
  
			static inline uint8_t __iCliRetVal(void)
			{
				cli();
 630:	f8 94       	cli
	{
		Buffer->InPtr    = (RingBuff_Data_t*)&Buffer->Buffer;
 632:	f1 8b       	std	Z+17, r31	; 0x11
 634:	e0 8b       	std	Z+16, r30	; 0x10
		Buffer->OutPtr   = (RingBuff_Data_t*)&Buffer->Buffer;
 636:	f3 8b       	std	Z+19, r31	; 0x13
 638:	e2 8b       	std	Z+18, r30	; 0x12
		Buffer->Elements = 0;
 63a:	14 8a       	std	Z+20, r1	; 0x14
				(void)__s;
			}

			static inline void __iRestore(const  uint8_t* __s)
			{
				SREG = *__s;
 63c:	8f bf       	out	0x3f, r24	; 63
				asm volatile ("" ::: "memory");
 63e:	08 95       	ret

00000640 <Buffer_GetElement>:
		  Buffer->InPtr = (RingBuff_Data_t*)&Buffer->Buffer;
	}
}

RingBuff_Data_t Buffer_GetElement(RingBuff_t* Buffer)
{
 640:	cf 93       	push	r28
 642:	df 93       	push	r29
 644:	dc 01       	movw	r26, r24
	RingBuff_Data_t BuffData;
	
	BUFF_ATOMIC_BLOCK
 646:	4f b7       	in	r20, 0x3f	; 63
				return 1;
			}
  
			static inline uint8_t __iCliRetVal(void)
			{
				cli();
 648:	f8 94       	cli
	{
#if defined(BUFF_EMPTYRETURNSZERO)
		if (!(Buffer->Elements))
 64a:	ec 01       	movw	r28, r24
 64c:	8c 89       	ldd	r24, Y+20	; 0x14
 64e:	88 23       	and	r24, r24
 650:	19 f4       	brne	.+6      	; 0x658 <Buffer_GetElement+0x18>
 652:	80 e0       	ldi	r24, 0x00	; 0
 654:	90 e0       	ldi	r25, 0x00	; 0
 656:	17 c0       	rjmp	.+46     	; 0x686 <Buffer_GetElement+0x46>
		  return 0;
#elif !defined(BUFF_NOEMPTYCHECK)
	#error No empty buffer check behaviour specified.
#endif

		BuffData = *(Buffer->OutPtr);
 658:	ed 01       	movw	r28, r26
 65a:	ea 89       	ldd	r30, Y+18	; 0x12
 65c:	fb 89       	ldd	r31, Y+19	; 0x13
 65e:	e0 81       	ld	r30, Z
	
		Buffer->OutPtr++;
 660:	8a 89       	ldd	r24, Y+18	; 0x12
 662:	9b 89       	ldd	r25, Y+19	; 0x13
 664:	01 96       	adiw	r24, 0x01	; 1
 666:	9b 8b       	std	Y+19, r25	; 0x13
 668:	8a 8b       	std	Y+18, r24	; 0x12
		Buffer->Elements--;
 66a:	8c 89       	ldd	r24, Y+20	; 0x14
 66c:	81 50       	subi	r24, 0x01	; 1
 66e:	8c 8b       	std	Y+20, r24	; 0x14
	
		if (Buffer->OutPtr == &Buffer->Buffer[BUFF_LENGTH])
 670:	2a 89       	ldd	r18, Y+18	; 0x12
 672:	3b 89       	ldd	r19, Y+19	; 0x13
 674:	cd 01       	movw	r24, r26
 676:	40 96       	adiw	r24, 0x10	; 16
 678:	28 17       	cp	r18, r24
 67a:	39 07       	cpc	r19, r25
 67c:	11 f4       	brne	.+4      	; 0x682 <Buffer_GetElement+0x42>
		  Buffer->OutPtr = (RingBuff_Data_t*)&Buffer->Buffer;
 67e:	bb 8b       	std	Y+19, r27	; 0x13
 680:	aa 8b       	std	Y+18, r26	; 0x12
 682:	81 e0       	ldi	r24, 0x01	; 1
 684:	90 e0       	ldi	r25, 0x00	; 0
				(void)__s;
			}

			static inline void __iRestore(const  uint8_t* __s)
			{
				SREG = *__s;
 686:	4f bf       	out	0x3f, r20	; 63
				asm volatile ("" ::: "memory");
 688:	01 97       	sbiw	r24, 0x01	; 1
 68a:	19 f0       	breq	.+6      	; 0x692 <Buffer_GetElement+0x52>
 68c:	80 e0       	ldi	r24, 0x00	; 0
 68e:	90 e0       	ldi	r25, 0x00	; 0
 690:	02 c0       	rjmp	.+4      	; 0x696 <Buffer_GetElement+0x56>
	}
	
	return BuffData;
 692:	8e 2f       	mov	r24, r30
 694:	99 27       	eor	r25, r25
 696:	df 91       	pop	r29
 698:	cf 91       	pop	r28
 69a:	08 95       	ret

0000069c <Buffer_StoreElement>:
		Buffer->Elements = 0;
	}
}

void Buffer_StoreElement(RingBuff_t* Buffer, RingBuff_Data_t Data)
{
 69c:	cf 93       	push	r28
 69e:	df 93       	push	r29
 6a0:	dc 01       	movw	r26, r24
	BUFF_ATOMIC_BLOCK
 6a2:	4f b7       	in	r20, 0x3f	; 63
				return 1;
			}
  
			static inline uint8_t __iCliRetVal(void)
			{
				cli();
 6a4:	f8 94       	cli
	{
	#if defined(BUFF_DROPOLD)
		if (Buffer->Elements == BUFF_LENGTH)
 6a6:	ec 01       	movw	r28, r24
 6a8:	8c 89       	ldd	r24, Y+20	; 0x14
 6aa:	80 31       	cpi	r24, 0x10	; 16
 6ac:	79 f4       	brne	.+30     	; 0x6cc <Buffer_StoreElement+0x30>
		{
			Buffer->OutPtr++;
 6ae:	8a 89       	ldd	r24, Y+18	; 0x12
 6b0:	9b 89       	ldd	r25, Y+19	; 0x13
 6b2:	01 96       	adiw	r24, 0x01	; 1
 6b4:	9b 8b       	std	Y+19, r25	; 0x13
 6b6:	8a 8b       	std	Y+18, r24	; 0x12
	
			if (Buffer->OutPtr == &Buffer->Buffer[BUFF_LENGTH])
 6b8:	2a 89       	ldd	r18, Y+18	; 0x12
 6ba:	3b 89       	ldd	r19, Y+19	; 0x13
 6bc:	cd 01       	movw	r24, r26
 6be:	40 96       	adiw	r24, 0x10	; 16
 6c0:	28 17       	cp	r18, r24
 6c2:	39 07       	cpc	r19, r25
 6c4:	39 f4       	brne	.+14     	; 0x6d4 <Buffer_StoreElement+0x38>
			  Buffer->OutPtr = (RingBuff_Data_t*)&Buffer->Buffer;
 6c6:	bb 8b       	std	Y+19, r27	; 0x13
 6c8:	aa 8b       	std	Y+18, r26	; 0x12
 6ca:	04 c0       	rjmp	.+8      	; 0x6d4 <Buffer_StoreElement+0x38>
		}
		else
		{
			Buffer->Elements++;
 6cc:	fd 01       	movw	r30, r26
 6ce:	84 89       	ldd	r24, Z+20	; 0x14
 6d0:	8f 5f       	subi	r24, 0xFF	; 255
 6d2:	84 8b       	std	Z+20, r24	; 0x14
		  Buffer->Elements++;
	#elif defined(BUFF_NODROPCHECK)
		  Buffer->Elements++;
	#endif
	
		*(Buffer->InPtr) = Data;
 6d4:	ed 01       	movw	r28, r26
 6d6:	e8 89       	ldd	r30, Y+16	; 0x10
 6d8:	f9 89       	ldd	r31, Y+17	; 0x11
 6da:	60 83       	st	Z, r22
		Buffer->InPtr++;
 6dc:	88 89       	ldd	r24, Y+16	; 0x10
 6de:	99 89       	ldd	r25, Y+17	; 0x11
 6e0:	01 96       	adiw	r24, 0x01	; 1
 6e2:	99 8b       	std	Y+17, r25	; 0x11
 6e4:	88 8b       	std	Y+16, r24	; 0x10
	
		if (Buffer->InPtr == &Buffer->Buffer[BUFF_LENGTH])
 6e6:	28 89       	ldd	r18, Y+16	; 0x10
 6e8:	39 89       	ldd	r19, Y+17	; 0x11
 6ea:	cd 01       	movw	r24, r26
 6ec:	40 96       	adiw	r24, 0x10	; 16
 6ee:	28 17       	cp	r18, r24
 6f0:	39 07       	cpc	r19, r25
 6f2:	11 f4       	brne	.+4      	; 0x6f8 <Buffer_StoreElement+0x5c>
		  Buffer->InPtr = (RingBuff_Data_t*)&Buffer->Buffer;
 6f4:	b9 8b       	std	Y+17, r27	; 0x11
 6f6:	a8 8b       	std	Y+16, r26	; 0x10
				(void)__s;
			}

			static inline void __iRestore(const  uint8_t* __s)
			{
				SREG = *__s;
 6f8:	4f bf       	out	0x3f, r20	; 63
				asm volatile ("" ::: "memory");
 6fa:	df 91       	pop	r29
 6fc:	cf 91       	pop	r28
 6fe:	08 95       	ret

00000700 <Scheduler_SetTaskMode>:
	
	return false;
}

void Scheduler_SetTaskMode(const TaskPtr_t Task, const bool TaskStatus)
{
 700:	9c 01       	movw	r18, r24
 702:	e0 e0       	ldi	r30, 0x00	; 0
 704:	f1 e0       	ldi	r31, 0x01	; 1
 706:	08 c0       	rjmp	.+16     	; 0x718 <Scheduler_SetTaskMode+0x18>
	TaskEntry_t* CurrTask = &Scheduler_TaskList[0];
					
	while (CurrTask != &Scheduler_TaskList[Scheduler_TotalTasks])
	{
		if (CurrTask->Task == Task)
 708:	80 81       	ld	r24, Z
 70a:	91 81       	ldd	r25, Z+1	; 0x01
 70c:	82 17       	cp	r24, r18
 70e:	93 07       	cpc	r25, r19
 710:	11 f4       	brne	.+4      	; 0x716 <Scheduler_SetTaskMode+0x16>
		{
			CurrTask->TaskStatus = TaskStatus;
 712:	62 83       	std	Z+2, r22	; 0x02
 714:	08 95       	ret
			break;
		}
		
		CurrTask++;
 716:	34 96       	adiw	r30, 0x04	; 4

void Scheduler_SetTaskMode(const TaskPtr_t Task, const bool TaskStatus)
{
	TaskEntry_t* CurrTask = &Scheduler_TaskList[0];
					
	while (CurrTask != &Scheduler_TaskList[Scheduler_TotalTasks])
 718:	80 91 4c 01 	lds	r24, 0x014C
 71c:	99 27       	eor	r25, r25
 71e:	88 0f       	add	r24, r24
 720:	99 1f       	adc	r25, r25
 722:	88 0f       	add	r24, r24
 724:	99 1f       	adc	r25, r25
 726:	80 50       	subi	r24, 0x00	; 0
 728:	9f 4f       	sbci	r25, 0xFF	; 255
 72a:	e8 17       	cp	r30, r24
 72c:	f9 07       	cpc	r31, r25
 72e:	61 f7       	brne	.-40     	; 0x708 <Scheduler_SetTaskMode+0x8>
 730:	08 95       	ret

00000732 <USB_SetupInterface>:
	UHWCON &= ~(1 << UIDE);
	#endif
}

void USB_SetupInterface(void)
{
 732:	0f 93       	push	r16
 734:	1f 93       	push	r17
 736:	cf 93       	push	r28
 738:	df 93       	push	r29
 73a:	cd b7       	in	r28, 0x3d	; 61
 73c:	de b7       	in	r29, 0x3e	; 62
 73e:	24 97       	sbiw	r28, 0x04	; 4
 740:	0f b6       	in	r0, 0x3f	; 63
 742:	f8 94       	cli
 744:	de bf       	out	0x3e, r29	; 62
 746:	0f be       	out	0x3f, r0	; 63
 748:	cd bf       	out	0x3d, r28	; 61
				UHIEN   = 0;
				OTGIEN  = 0;
				#endif
				
				#if defined(USB_CAN_BE_DEVICE)
				UDIEN   = 0;
 74a:	10 92 e2 00 	sts	0x00E2, r1
				UHINT   = 0;
				OTGINT  = 0;
				#endif
				
				#if defined(USB_CAN_BE_DEVICE)
				UDINT   = 0;
 74e:	10 92 e1 00 	sts	0x00E1, r1
	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();

	USB_IsConnected         = false;
 752:	10 92 51 01 	sts	0x0151, r1
	USB_IsInitialized       = false;
 756:	10 92 50 01 	sts	0x0150, r1
	#if defined(USB_CAN_BE_HOST)
	USB_HostState           = HOST_STATE_Unattached;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	USB_ConfigurationNumber = 0;
 75a:	10 92 4f 01 	sts	0x014F, r1
	#if defined(__AVR_ATmega32U4__) && !defined(MANUAL_PLL_CONTROL)
	PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
	#endif
	
	#if !defined(MANUAL_PLL_CONTROL)
	USB_PLL_On();
 75e:	19 bc       	out	0x29, r1	; 41
 760:	89 b5       	in	r24, 0x29	; 41
 762:	82 60       	ori	r24, 0x02	; 2
 764:	89 bd       	out	0x29, r24	; 41
	#endif

	while (!(USB_PLL_IsReady()));
 766:	09 b4       	in	r0, 0x29	; 41
 768:	00 fe       	sbrs	r0, 0
 76a:	fd cf       	rjmp	.-6      	; 0x766 <USB_SetupInterface+0x34>
		
	USB_Interface_Reset();
 76c:	80 91 d8 00 	lds	r24, 0x00D8
 770:	98 2f       	mov	r25, r24
 772:	9f 77       	andi	r25, 0x7F	; 127
 774:	90 93 d8 00 	sts	0x00D8, r25
 778:	80 68       	ori	r24, 0x80	; 128
 77a:	80 93 d8 00 	sts	0x00D8, r24
		USB_INT_Enable(USB_INT_VBUS);
		#endif
	#endif
		
	if (!(USB_Options & USB_OPT_REG_DISABLED))
	  USB_REG_On();
 77e:	80 91 63 00 	lds	r24, 0x0063
 782:	8e 7f       	andi	r24, 0xFE	; 254
 784:	80 93 63 00 	sts	0x0063, r24
	
	USB_CLK_Unfreeze();
 788:	80 91 d8 00 	lds	r24, 0x00D8
 78c:	8f 7d       	andi	r24, 0xDF	; 223
 78e:	80 93 d8 00 	sts	0x00D8, r24
	
	#if defined(USB_CAN_BE_DEVICE)
	USB_Descriptor_Device_t* DeviceDescriptorPtr;
	uint16_t                 DeviceDescriptorSize;

	if (USB_GetDescriptor(DTYPE_Device, 0, 0, (void*)&DeviceDescriptorPtr, &DeviceDescriptorSize) == true)
 792:	8e 01       	movw	r16, r28
 794:	0d 5f       	subi	r16, 0xFD	; 253
 796:	1f 4f       	sbci	r17, 0xFF	; 255
 798:	9e 01       	movw	r18, r28
 79a:	2f 5f       	subi	r18, 0xFF	; 255
 79c:	3f 4f       	sbci	r19, 0xFF	; 255
 79e:	40 e0       	ldi	r20, 0x00	; 0
 7a0:	50 e0       	ldi	r21, 0x00	; 0
 7a2:	60 e0       	ldi	r22, 0x00	; 0
 7a4:	81 e0       	ldi	r24, 0x01	; 1
 7a6:	05 df       	rcall	.-502    	; 0x5b2 <USB_GetDescriptor>
 7a8:	88 23       	and	r24, r24
 7aa:	31 f0       	breq	.+12     	; 0x7b8 <USB_SetupInterface+0x86>
		#if defined(USE_RAM_DESCRIPTORS)
			USB_ControlEndpointSize = DeviceDescriptorPtr->Endpoint0Size;
		#elif defined (USE_EEPROM_DESCRIPTORS)
			USB_ControlEndpointSize = eeprom_read_byte(&DeviceDescriptorPtr->Endpoint0Size);
		#else
			USB_ControlEndpointSize = pgm_read_byte(&DeviceDescriptorPtr->Endpoint0Size);
 7ac:	e9 81       	ldd	r30, Y+1	; 0x01
 7ae:	fa 81       	ldd	r31, Y+2	; 0x02
 7b0:	37 96       	adiw	r30, 0x07	; 7
 7b2:	e4 91       	lpm	r30, Z
 7b4:	e0 93 1b 01 	sts	0x011B, r30
		#endif
	}
	#endif

	USB_Attach();
 7b8:	80 91 e0 00 	lds	r24, 0x00E0
 7bc:	8e 7f       	andi	r24, 0xFE	; 254
 7be:	80 93 e0 00 	sts	0x00E0, r24
	
	#if defined(USB_DEVICE_ONLY)	
	USB_INT_Enable(USB_INT_SUSPEND);
 7c2:	80 91 e2 00 	lds	r24, 0x00E2
 7c6:	81 60       	ori	r24, 0x01	; 1
 7c8:	80 93 e2 00 	sts	0x00E2, r24
	USB_INT_Enable(USB_INT_EORSTI);	
 7cc:	80 91 e2 00 	lds	r24, 0x00E2
 7d0:	88 60       	ori	r24, 0x08	; 8
 7d2:	80 93 e2 00 	sts	0x00E2, r24
	#endif
	
	#if defined(USB_CAN_BE_BOTH)
	USB_InitTaskPointer();
	#else
	USB_IsInitialized = true;
 7d6:	81 e0       	ldi	r24, 0x01	; 1
 7d8:	80 93 50 01 	sts	0x0150, r24
 7dc:	24 96       	adiw	r28, 0x04	; 4
 7de:	0f b6       	in	r0, 0x3f	; 63
 7e0:	f8 94       	cli
 7e2:	de bf       	out	0x3e, r29	; 62
 7e4:	0f be       	out	0x3f, r0	; 63
 7e6:	cd bf       	out	0x3d, r28	; 61
 7e8:	df 91       	pop	r29
 7ea:	cf 91       	pop	r28
 7ec:	1f 91       	pop	r17
 7ee:	0f 91       	pop	r16
 7f0:	08 95       	ret

000007f2 <USB_ShutDown>:
	
	sei();
}

void USB_ShutDown(void)
{
 7f2:	80 91 51 01 	lds	r24, 0x0151
 7f6:	88 23       	and	r24, r24
 7f8:	09 f0       	breq	.+2      	; 0x7fc <USB_ShutDown+0xa>
	if (USB_IsConnected)
	  RAISE_EVENT(USB_Disconnect);
 7fa:	31 dd       	rcall	.-1438   	; 0x25e <Event_USB_Disconnect>
				UHIEN   = 0;
				OTGIEN  = 0;
				#endif
				
				#if defined(USB_CAN_BE_DEVICE)
				UDIEN   = 0;
 7fc:	10 92 e2 00 	sts	0x00E2, r1
				UHINT   = 0;
				OTGINT  = 0;
				#endif
				
				#if defined(USB_CAN_BE_DEVICE)
				UDINT   = 0;
 800:	10 92 e1 00 	sts	0x00E1, r1

	USB_INT_DisableAllInterrupts();
	USB_INT_ClearAllInterrupts();

	USB_IsConnected         = false;
 804:	10 92 51 01 	sts	0x0151, r1
	USB_IsInitialized       = false;
 808:	10 92 50 01 	sts	0x0150, r1
	#if defined(USB_CAN_BE_HOST)
	USB_HostState           = HOST_STATE_Unattached;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	USB_ConfigurationNumber = 0;
 80c:	10 92 4f 01 	sts	0x014F, r1
	
	#if !defined(USE_STATIC_OPTIONS)
	USB_Options     = 0;
	#endif

	USB_Interface_Disable();
 810:	80 91 d8 00 	lds	r24, 0x00D8
 814:	8f 77       	andi	r24, 0x7F	; 127
 816:	80 93 d8 00 	sts	0x00D8, r24
	USB_PLL_Off();
 81a:	19 bc       	out	0x29, r1	; 41
 81c:	08 95       	ret

0000081e <USB_Init>:
			   
               #if !defined(USE_STATIC_OPTIONS)
               const uint8_t Options
               #endif
               )
{
 81e:	1f 93       	push	r17
	if (USB_IsInitialized)
 820:	80 91 50 01 	lds	r24, 0x0150
 824:	88 23       	and	r24, r24
 826:	09 f0       	breq	.+2      	; 0x82a <USB_Init+0xc>
	  USB_ShutDown();
 828:	e4 df       	rcall	.-56     	; 0x7f2 <USB_ShutDown>
	#endif

	#if defined(USB_CAN_BE_BOTH)
	USB_InitTaskPointer();
	#else
	USB_IsInitialized = true;
 82a:	11 e0       	ldi	r17, 0x01	; 1
 82c:	10 93 50 01 	sts	0x0150, r17
	USB_IsConnected   = false;
 830:	10 92 51 01 	sts	0x0151, r1

	#if defined(USB_DEVICE_ONLY)
		#if defined(USB_FULL_CONTROLLER)
		USB_INT_Enable(USB_INT_VBUS);
		#else
		USB_SetupInterface();
 834:	7e df       	rcall	.-260    	; 0x732 <USB_SetupInterface>
		USB_IsConnected = true;
 836:	10 93 51 01 	sts	0x0151, r17
	  USB_INT_Enable(USB_INT_VBUS);
	else
	  USB_SetupInterface();
	#endif
	
	sei();
 83a:	78 94       	sei
 83c:	1f 91       	pop	r17
 83e:	08 95       	ret

00000840 <Endpoint_ConfigureEndpoint_P>:

void Endpoint_ConfigureEndpoint_P(const uint8_t EndpointNum,
                                  const uint16_t EndpointSize,
                                  const uint8_t UECFG0Xdata,
                                  const uint8_t UECFG1Xdata)
{
 840:	80 93 e9 00 	sts	0x00E9, r24
	Endpoint_SelectEndpoint(EndpointNum);
	Endpoint_EnableEndpoint();
 844:	80 91 eb 00 	lds	r24, 0x00EB
 848:	81 60       	ori	r24, 0x01	; 1
 84a:	80 93 eb 00 	sts	0x00EB, r24
	
	UECFG0X = UECFG0Xdata;
 84e:	40 93 ec 00 	sts	0x00EC, r20
	UECFG1X = ((UECFG1X & (1 << ALLOC)) | UECFG1Xdata | Endpoint_BytesToEPSizeMask(EndpointSize));
 852:	30 91 ed 00 	lds	r19, 0x00ED
			static inline uint8_t Endpoint_BytesToEPSizeMask(uint16_t Bytes)
			{
				uint8_t SizeCheck = 8;
				uint8_t SizeMask  = 0;

				Bytes &= ENDPOINT_EPSIZE_MASK;
 856:	77 70       	andi	r23, 0x07	; 7

				do
				{
					if (Bytes <= SizeCheck)
 858:	69 30       	cpi	r22, 0x09	; 9
 85a:	71 05       	cpc	r23, r1
 85c:	10 f4       	brcc	.+4      	; 0x862 <Endpoint_ConfigureEndpoint_P+0x22>
 85e:	80 e0       	ldi	r24, 0x00	; 0
 860:	07 c0       	rjmp	.+14     	; 0x870 <Endpoint_ConfigureEndpoint_P+0x30>
 862:	61 31       	cpi	r22, 0x11	; 17
 864:	71 05       	cpc	r23, r1
 866:	18 f0       	brcs	.+6      	; 0x86e <Endpoint_ConfigureEndpoint_P+0x2e>
 868:	80 e3       	ldi	r24, 0x30	; 48
 86a:	90 e0       	ldi	r25, 0x00	; 0
 86c:	04 c0       	rjmp	.+8      	; 0x876 <Endpoint_ConfigureEndpoint_P+0x36>
 86e:	81 e0       	ldi	r24, 0x01	; 1
					  return (SizeMask << EPSIZE0);
 870:	82 95       	swap	r24
 872:	80 7f       	andi	r24, 0xF0	; 240
 874:	99 27       	eor	r25, r25
 876:	32 70       	andi	r19, 0x02	; 2
 878:	23 2b       	or	r18, r19
 87a:	28 2b       	or	r18, r24
 87c:	20 93 ed 00 	sts	0x00ED, r18
	
	Endpoint_AllocateMemory();
 880:	80 91 ed 00 	lds	r24, 0x00ED
 884:	82 60       	ori	r24, 0x02	; 2
 886:	80 93 ed 00 	sts	0x00ED, r24
 88a:	08 95       	ret

0000088c <USB_Device_ProcessControlPacket>:
#include "DevChapter9.h"

uint8_t USB_ConfigurationNumber;

void USB_Device_ProcessControlPacket(void)
{
 88c:	ef 92       	push	r14
 88e:	ff 92       	push	r15
 890:	0f 93       	push	r16
 892:	1f 93       	push	r17
 894:	cf 93       	push	r28
 896:	df 93       	push	r29
 898:	cd b7       	in	r28, 0x3d	; 61
 89a:	de b7       	in	r29, 0x3e	; 62
 89c:	28 97       	sbiw	r28, 0x08	; 8
 89e:	0f b6       	in	r0, 0x3f	; 63
 8a0:	f8 94       	cli
 8a2:	de bf       	out	0x3e, r29	; 62
 8a4:	0f be       	out	0x3f, r0	; 63
 8a6:	cd bf       	out	0x3d, r28	; 61
		/* Inline Functions: */
			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 8a8:	60 91 f1 00 	lds	r22, 0x00F1
 8ac:	26 2f       	mov	r18, r22
 8ae:	33 27       	eor	r19, r19
	bool    RequestHandled = false;
	
	RequestType = Endpoint_Read_Byte();
	Request     = Endpoint_Read_Byte();
	
	switch (Request)
 8b0:	90 91 f1 00 	lds	r25, 0x00F1
 8b4:	95 30       	cpi	r25, 0x05	; 5
 8b6:	09 f4       	brne	.+2      	; 0x8ba <USB_Device_ProcessControlPacket+0x2e>
 8b8:	b6 c0       	rjmp	.+364    	; 0xa26 <USB_Device_ProcessControlPacket+0x19a>
 8ba:	96 30       	cpi	r25, 0x06	; 6
 8bc:	48 f4       	brcc	.+18     	; 0x8d0 <USB_Device_ProcessControlPacket+0x44>
 8be:	91 30       	cpi	r25, 0x01	; 1
 8c0:	09 f4       	brne	.+2      	; 0x8c4 <USB_Device_ProcessControlPacket+0x38>
 8c2:	66 c0       	rjmp	.+204    	; 0x990 <USB_Device_ProcessControlPacket+0x104>
 8c4:	91 30       	cpi	r25, 0x01	; 1
 8c6:	70 f0       	brcs	.+28     	; 0x8e4 <USB_Device_ProcessControlPacket+0x58>
 8c8:	93 30       	cpi	r25, 0x03	; 3
 8ca:	09 f0       	breq	.+2      	; 0x8ce <USB_Device_ProcessControlPacket+0x42>
 8cc:	7a c1       	rjmp	.+756    	; 0xbc2 <USB_Device_ProcessControlPacket+0x336>
 8ce:	60 c0       	rjmp	.+192    	; 0x990 <USB_Device_ProcessControlPacket+0x104>
 8d0:	98 30       	cpi	r25, 0x08	; 8
 8d2:	09 f4       	brne	.+2      	; 0x8d6 <USB_Device_ProcessControlPacket+0x4a>
 8d4:	32 c1       	rjmp	.+612    	; 0xb3a <USB_Device_ProcessControlPacket+0x2ae>
 8d6:	99 30       	cpi	r25, 0x09	; 9
 8d8:	09 f4       	brne	.+2      	; 0x8dc <USB_Device_ProcessControlPacket+0x50>
 8da:	4a c1       	rjmp	.+660    	; 0xb70 <USB_Device_ProcessControlPacket+0x2e4>
 8dc:	96 30       	cpi	r25, 0x06	; 6
 8de:	09 f0       	breq	.+2      	; 0x8e2 <USB_Device_ProcessControlPacket+0x56>
 8e0:	70 c1       	rjmp	.+736    	; 0xbc2 <USB_Device_ProcessControlPacket+0x336>
 8e2:	c1 c0       	rjmp	.+386    	; 0xa66 <USB_Device_ProcessControlPacket+0x1da>
	{
		case REQ_GetStatus:
			if (((RequestType & (CONTROL_REQTYPE_DIRECTION | CONTROL_REQTYPE_TYPE)) ==
 8e4:	82 2f       	mov	r24, r18
 8e6:	80 7e       	andi	r24, 0xE0	; 224
 8e8:	09 f0       	breq	.+2      	; 0x8ec <USB_Device_ProcessControlPacket+0x60>
 8ea:	6b c1       	rjmp	.+726    	; 0xbc2 <USB_Device_ProcessControlPacket+0x336>
 8ec:	2f 71       	andi	r18, 0x1F	; 31
 8ee:	30 70       	andi	r19, 0x00	; 0
 8f0:	23 30       	cpi	r18, 0x03	; 3
 8f2:	31 05       	cpc	r19, r1
 8f4:	09 f4       	brne	.+2      	; 0x8f8 <USB_Device_ProcessControlPacket+0x6c>
 8f6:	65 c1       	rjmp	.+714    	; 0xbc2 <USB_Device_ProcessControlPacket+0x336>
			/** Discards two bytes from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline void Endpoint_Ignore_Word(void)
			{
				uint8_t Dummy;
				
				Dummy = UEDATX;
 8f8:	80 91 f1 00 	lds	r24, 0x00F1
				Dummy = UEDATX;
 8fc:	80 91 f1 00 	lds	r24, 0x00F1
		/* Inline Functions: */
			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 900:	80 91 f1 00 	lds	r24, 0x00F1
	uint8_t                                ConfigAttributes;

	Endpoint_Ignore_Word();
	EndpointIndex = (Endpoint_Read_Byte() & ENDPOINT_EPNUM_MASK);
	
	switch (RequestType & CONTROL_REQTYPE_RECIPIENT)
 904:	21 30       	cpi	r18, 0x01	; 1
 906:	31 05       	cpc	r19, r1
 908:	31 f0       	breq	.+12     	; 0x916 <USB_Device_ProcessControlPacket+0x8a>
 90a:	22 30       	cpi	r18, 0x02	; 2
 90c:	31 05       	cpc	r19, r1
 90e:	21 f1       	breq	.+72     	; 0x958 <USB_Device_ProcessControlPacket+0xcc>
 910:	23 2b       	or	r18, r19
 912:	19 f0       	breq	.+6      	; 0x91a <USB_Device_ProcessControlPacket+0x8e>
 914:	58 c1       	rjmp	.+688    	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
 916:	90 e0       	ldi	r25, 0x00	; 0
 918:	28 c0       	rjmp	.+80     	; 0x96a <USB_Device_ProcessControlPacket+0xde>
	{
		case REQREC_DEVICE:
			if (USB_GetDescriptor(DTYPE_Configuration, USB_ConfigurationNumber, 0, (void*)&ConfigDescriptorPtr, &ConfigDescriptorSize) == false)
 91a:	8e 01       	movw	r16, r28
 91c:	09 5f       	subi	r16, 0xF9	; 249
 91e:	1f 4f       	sbci	r17, 0xFF	; 255
 920:	9e 01       	movw	r18, r28
 922:	2f 5f       	subi	r18, 0xFF	; 255
 924:	3f 4f       	sbci	r19, 0xFF	; 255
 926:	40 e0       	ldi	r20, 0x00	; 0
 928:	50 e0       	ldi	r21, 0x00	; 0
 92a:	60 91 4f 01 	lds	r22, 0x014F
 92e:	82 e0       	ldi	r24, 0x02	; 2
 930:	40 de       	rcall	.-896    	; 0x5b2 <USB_GetDescriptor>
 932:	88 23       	and	r24, r24
 934:	09 f4       	brne	.+2      	; 0x938 <USB_Device_ProcessControlPacket+0xac>
 936:	47 c1       	rjmp	.+654    	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
#if defined(USE_RAM_DESCRIPTORS)
			ConfigAttributes = ConfigDescriptorPtr->ConfigAttributes;
#elif defined (USE_EEPROM_DESCRIPTORS)
			ConfigAttributes = eeprom_read_byte(&ConfigDescriptorPtr->ConfigAttributes);
#else
			ConfigAttributes = pgm_read_byte(&ConfigDescriptorPtr->ConfigAttributes);
 938:	e9 81       	ldd	r30, Y+1	; 0x01
 93a:	fa 81       	ldd	r31, Y+2	; 0x02
 93c:	37 96       	adiw	r30, 0x07	; 7
 93e:	e4 91       	lpm	r30, Z
#endif

			if (ConfigAttributes & USB_CONFIG_ATTR_SELFPOWERED)
 940:	ff 27       	eor	r31, r31
 942:	8e 2f       	mov	r24, r30
 944:	80 7c       	andi	r24, 0xC0	; 192
 946:	11 f0       	breq	.+4      	; 0x94c <USB_Device_ProcessControlPacket+0xc0>
 948:	92 e0       	ldi	r25, 0x02	; 2
 94a:	01 c0       	rjmp	.+2      	; 0x94e <USB_Device_ProcessControlPacket+0xc2>
 94c:	90 e0       	ldi	r25, 0x00	; 0
			  StatusByte  = FEATURE_SELFPOWERED;
			
			if (ConfigAttributes & USB_CONFIG_ATTR_REMOTEWAKEUP)
 94e:	8e 2f       	mov	r24, r30
 950:	80 7a       	andi	r24, 0xA0	; 160
 952:	59 f0       	breq	.+22     	; 0x96a <USB_Device_ProcessControlPacket+0xde>
			  StatusByte |= FEATURE_REMOTE_WAKEUP;
 954:	91 60       	ori	r25, 0x01	; 1
 956:	09 c0       	rjmp	.+18     	; 0x96a <USB_Device_ProcessControlPacket+0xde>
	USB_Descriptor_Configuration_Header_t* ConfigDescriptorPtr;
	uint16_t                               ConfigDescriptorSize;
	uint8_t                                ConfigAttributes;

	Endpoint_Ignore_Word();
	EndpointIndex = (Endpoint_Read_Byte() & ENDPOINT_EPNUM_MASK);
 958:	87 70       	andi	r24, 0x07	; 7
		case REQREC_INTERFACE:
			// No bits set, all bits currently reserved
				
			break;
		case REQREC_ENDPOINT:
			Endpoint_SelectEndpoint(EndpointIndex);
 95a:	80 93 e9 00 	sts	0x00E9, r24

			if (!(Endpoint_IsEnabled()))
 95e:	90 91 eb 00 	lds	r25, 0x00EB
 962:	90 95       	com	r25
 964:	91 70       	andi	r25, 0x01	; 1
			  StatusByte = 0x01;

			Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);			  
 966:	10 92 e9 00 	sts	0x00E9, r1
			break;
		default:
			return;
	}
	
	Endpoint_ClearSetupReceived();
 96a:	80 91 e8 00 	lds	r24, 0x00E8
 96e:	87 7f       	andi	r24, 0xF7	; 247
 970:	80 93 e8 00 	sts	0x00E8, r24
			}

			/** Writes one byte from the currently selected endpoint's bank, for IN direction endpoints. */
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 974:	90 93 f1 00 	sts	0x00F1, r25
	
	Endpoint_Write_Byte(StatusByte);
	Endpoint_Write_Byte(0x00);

	Endpoint_ClearSetupIN();
 978:	10 92 f1 00 	sts	0x00F1, r1
 97c:	80 91 e8 00 	lds	r24, 0x00E8
 980:	8e 7f       	andi	r24, 0xFE	; 254
 982:	80 93 e8 00 	sts	0x00E8, r24
	
	while (!(Endpoint_IsSetupOUTReceived()));
 986:	80 91 e8 00 	lds	r24, 0x00E8
 98a:	82 ff       	sbrs	r24, 2
 98c:	fc cf       	rjmp	.-8      	; 0x986 <USB_Device_ProcessControlPacket+0xfa>
 98e:	ea c0       	rjmp	.+468    	; 0xb64 <USB_Device_ProcessControlPacket+0x2d8>
			}			

			break;
		case REQ_ClearFeature:
		case REQ_SetFeature:
			if (((RequestType & (CONTROL_REQTYPE_DIRECTION | CONTROL_REQTYPE_TYPE)) ==
 990:	82 2f       	mov	r24, r18
 992:	80 7e       	andi	r24, 0xE0	; 224
 994:	09 f0       	breq	.+2      	; 0x998 <USB_Device_ProcessControlPacket+0x10c>
 996:	15 c1       	rjmp	.+554    	; 0xbc2 <USB_Device_ProcessControlPacket+0x336>
 998:	2f 71       	andi	r18, 0x1F	; 31
 99a:	30 70       	andi	r19, 0x00	; 0
 99c:	23 30       	cpi	r18, 0x03	; 3
 99e:	31 05       	cpc	r19, r1
 9a0:	09 f4       	brne	.+2      	; 0x9a4 <USB_Device_ProcessControlPacket+0x118>
 9a2:	0f c1       	rjmp	.+542    	; 0xbc2 <USB_Device_ProcessControlPacket+0x336>
		/* Inline Functions: */
			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 9a4:	40 91 f1 00 	lds	r20, 0x00F1
			/** Discards one byte from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline void Endpoint_Ignore_Byte(void)
			{
				uint8_t Dummy;
				
				Dummy = UEDATX;
 9a8:	80 91 f1 00 	lds	r24, 0x00F1
		/* Inline Functions: */
			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 9ac:	80 91 f1 00 	lds	r24, 0x00F1

	Feature       = Endpoint_Read_Byte();
	Endpoint_Ignore_Byte();
	EndpointIndex = (Endpoint_Read_Byte() & ENDPOINT_EPNUM_MASK);

	switch (RequestType & CONTROL_REQTYPE_RECIPIENT)
 9b0:	22 30       	cpi	r18, 0x02	; 2
 9b2:	31 05       	cpc	r19, r1
 9b4:	09 f0       	breq	.+2      	; 0x9b8 <USB_Device_ProcessControlPacket+0x12c>
 9b6:	07 c1       	rjmp	.+526    	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
	{
		case REQREC_ENDPOINT:
			if (Feature == FEATURE_ENDPOINT)
 9b8:	44 23       	and	r20, r20
 9ba:	09 f0       	breq	.+2      	; 0x9be <USB_Device_ProcessControlPacket+0x132>
 9bc:	04 c1       	rjmp	.+520    	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
	uint8_t EndpointIndex;
	uint8_t Feature;

	Feature       = Endpoint_Read_Byte();
	Endpoint_Ignore_Byte();
	EndpointIndex = (Endpoint_Read_Byte() & ENDPOINT_EPNUM_MASK);
 9be:	28 2f       	mov	r18, r24
 9c0:	27 70       	andi	r18, 0x07	; 7
	switch (RequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		case REQREC_ENDPOINT:
			if (Feature == FEATURE_ENDPOINT)
			{
				Endpoint_SelectEndpoint(EndpointIndex);
 9c2:	20 93 e9 00 	sts	0x00E9, r18

				if (Endpoint_IsEnabled())
 9c6:	80 91 eb 00 	lds	r24, 0x00EB
 9ca:	80 ff       	sbrs	r24, 0
 9cc:	29 c0       	rjmp	.+82     	; 0xa20 <USB_Device_ProcessControlPacket+0x194>
				{				
					if (EndpointIndex != ENDPOINT_CONTROLEP)
 9ce:	22 23       	and	r18, r18
 9d0:	d9 f0       	breq	.+54     	; 0xa08 <USB_Device_ProcessControlPacket+0x17c>
					{
						if (Request == REQ_ClearFeature)
 9d2:	91 30       	cpi	r25, 0x01	; 1
 9d4:	a1 f4       	brne	.+40     	; 0x9fe <USB_Device_ProcessControlPacket+0x172>
						{
							Endpoint_ClearStall();
 9d6:	80 91 eb 00 	lds	r24, 0x00EB
 9da:	80 61       	ori	r24, 0x10	; 16
 9dc:	80 93 eb 00 	sts	0x00EB, r24
							Endpoint_ResetFIFO(EndpointIndex);
 9e0:	81 e0       	ldi	r24, 0x01	; 1
 9e2:	90 e0       	ldi	r25, 0x00	; 0
 9e4:	02 c0       	rjmp	.+4      	; 0x9ea <USB_Device_ProcessControlPacket+0x15e>
 9e6:	88 0f       	add	r24, r24
 9e8:	99 1f       	adc	r25, r25
 9ea:	2a 95       	dec	r18
 9ec:	e2 f7       	brpl	.-8      	; 0x9e6 <USB_Device_ProcessControlPacket+0x15a>
 9ee:	80 93 ea 00 	sts	0x00EA, r24
 9f2:	10 92 ea 00 	sts	0x00EA, r1
							Endpoint_ResetDataToggle();
 9f6:	80 91 eb 00 	lds	r24, 0x00EB
 9fa:	88 60       	ori	r24, 0x08	; 8
 9fc:	03 c0       	rjmp	.+6      	; 0xa04 <USB_Device_ProcessControlPacket+0x178>
						}
						else
						{
							Endpoint_StallTransaction();						
 9fe:	80 91 eb 00 	lds	r24, 0x00EB
 a02:	80 62       	ori	r24, 0x20	; 32
 a04:	80 93 eb 00 	sts	0x00EB, r24
						}
					}

					Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
 a08:	10 92 e9 00 	sts	0x00E9, r1
					Endpoint_ClearSetupReceived();
 a0c:	80 91 e8 00 	lds	r24, 0x00E8
 a10:	87 7f       	andi	r24, 0xF7	; 247
 a12:	80 93 e8 00 	sts	0x00E8, r24
					Endpoint_ClearSetupIN();
 a16:	80 91 e8 00 	lds	r24, 0x00E8
 a1a:	8e 7f       	andi	r24, 0xFE	; 254
 a1c:	80 93 e8 00 	sts	0x00E8, r24
				}
				
				Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);			
 a20:	10 92 e9 00 	sts	0x00E9, r1
 a24:	d0 c0       	rjmp	.+416    	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
				RequestHandled = true;
			}

			break;
		case REQ_SetAddress:
			if (RequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
 a26:	66 23       	and	r22, r22
 a28:	09 f0       	breq	.+2      	; 0xa2c <USB_Device_ProcessControlPacket+0x1a0>
 a2a:	cb c0       	rjmp	.+406    	; 0xbc2 <USB_Device_ProcessControlPacket+0x336>
 a2c:	90 91 f1 00 	lds	r25, 0x00F1

static void USB_Device_SetAddress(void)
{
	uint8_t NewAddress = Endpoint_Read_Byte();

	UDADDR = ((UDADDR & (1 << ADDEN)) | (NewAddress & 0x3F));
 a30:	80 91 e3 00 	lds	r24, 0x00E3
 a34:	9f 73       	andi	r25, 0x3F	; 63
 a36:	80 78       	andi	r24, 0x80	; 128
 a38:	98 2b       	or	r25, r24
 a3a:	90 93 e3 00 	sts	0x00E3, r25

	Endpoint_ClearSetupReceived();
 a3e:	80 91 e8 00 	lds	r24, 0x00E8
 a42:	87 7f       	andi	r24, 0xF7	; 247
 a44:	80 93 e8 00 	sts	0x00E8, r24

	Endpoint_ClearSetupIN();
 a48:	80 91 e8 00 	lds	r24, 0x00E8
 a4c:	8e 7f       	andi	r24, 0xFE	; 254
 a4e:	80 93 e8 00 	sts	0x00E8, r24
	while (!(Endpoint_IsSetupINReady()));
 a52:	80 91 e8 00 	lds	r24, 0x00E8
 a56:	80 ff       	sbrs	r24, 0
 a58:	fc cf       	rjmp	.-8      	; 0xa52 <USB_Device_ProcessControlPacket+0x1c6>
	
	UDADDR |= (1 << ADDEN);
 a5a:	80 91 e3 00 	lds	r24, 0x00E3
 a5e:	80 68       	ori	r24, 0x80	; 128
 a60:	80 93 e3 00 	sts	0x00E3, r24
 a64:	b0 c0       	rjmp	.+352    	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
 a66:	60 91 f1 00 	lds	r22, 0x00F1
			static inline uint16_t Endpoint_Read_Word_LE(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t Endpoint_Read_Word_LE(void)
			{
				uint16_t Data;
				
				Data  = UEDATX;
 a6a:	80 91 f1 00 	lds	r24, 0x00F1
 a6e:	20 91 f1 00 	lds	r18, 0x00F1
				Data |= (((uint16_t)UEDATX) << 8);
 a72:	40 91 f1 00 	lds	r20, 0x00F1
			static inline uint16_t Endpoint_Read_Word_LE(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t Endpoint_Read_Word_LE(void)
			{
				uint16_t Data;
				
				Data  = UEDATX;
 a76:	e0 90 f1 00 	lds	r14, 0x00F1
				Data |= (((uint16_t)UEDATX) << 8);
 a7a:	f0 90 f1 00 	lds	r15, 0x00F1
	void*    DescriptorPointer;
	uint16_t DescriptorSize;
	
	bool     SendZLP;
	
	if (!(USB_GetDescriptor(DescriptorType, DescriptorIndex, DescriptorLanguageID,
 a7e:	55 27       	eor	r21, r21
 a80:	54 2f       	mov	r21, r20
 a82:	44 27       	eor	r20, r20
 a84:	33 27       	eor	r19, r19
 a86:	42 2b       	or	r20, r18
 a88:	53 2b       	or	r21, r19
 a8a:	8e 01       	movw	r16, r28
 a8c:	09 5f       	subi	r16, 0xF9	; 249
 a8e:	1f 4f       	sbci	r17, 0xFF	; 255
 a90:	9e 01       	movw	r18, r28
 a92:	2d 5f       	subi	r18, 0xFD	; 253
 a94:	3f 4f       	sbci	r19, 0xFF	; 255
 a96:	8d dd       	rcall	.-1254   	; 0x5b2 <USB_GetDescriptor>
 a98:	88 23       	and	r24, r24
 a9a:	09 f4       	brne	.+2      	; 0xa9e <USB_Device_ProcessControlPacket+0x212>
 a9c:	94 c0       	rjmp	.+296    	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
	                        &DescriptorPointer, &DescriptorSize)))
	{
		return;
	}
	
	Endpoint_ClearSetupReceived();
 a9e:	80 91 e8 00 	lds	r24, 0x00E8
 aa2:	87 7f       	andi	r24, 0xF7	; 247
 aa4:	80 93 e8 00 	sts	0x00E8, r24
 aa8:	8f 2d       	mov	r24, r15
 aaa:	99 27       	eor	r25, r25
 aac:	58 2f       	mov	r21, r24
 aae:	44 27       	eor	r20, r20
 ab0:	8e 2d       	mov	r24, r14
 ab2:	99 27       	eor	r25, r25
 ab4:	2f 81       	ldd	r18, Y+7	; 0x07
 ab6:	38 85       	ldd	r19, Y+8	; 0x08
 ab8:	48 2b       	or	r20, r24
 aba:	59 2b       	or	r21, r25
 abc:	24 17       	cp	r18, r20
 abe:	35 07       	cpc	r19, r21
 ac0:	08 f4       	brcc	.+2      	; 0xac4 <USB_Device_ProcessControlPacket+0x238>
 ac2:	a9 01       	movw	r20, r18
	
	if (DescriptorBytesToSend > DescriptorSize)
	  DescriptorBytesToSend = DescriptorSize;
	  
	SendZLP = !(DescriptorBytesToSend % USB_ControlEndpointSize);
 ac4:	90 91 1b 01 	lds	r25, 0x011B
 ac8:	69 2f       	mov	r22, r25
 aca:	77 27       	eor	r23, r23
 acc:	ab 81       	ldd	r26, Y+3	; 0x03
 ace:	bc 81       	ldd	r27, Y+4	; 0x04
 ad0:	9a 01       	movw	r18, r20
 ad2:	16 c0       	rjmp	.+44     	; 0xb00 <USB_Device_ProcessControlPacket+0x274>
	
	while (DescriptorBytesToSend && (!(Endpoint_IsSetupOUTReceived())))
	{
		while (!(Endpoint_IsSetupINReady()));
 ad4:	80 91 e8 00 	lds	r24, 0x00E8
 ad8:	80 fd       	sbrc	r24, 0
 ada:	09 c0       	rjmp	.+18     	; 0xaee <USB_Device_ProcessControlPacket+0x262>
 adc:	fb cf       	rjmp	.-10     	; 0xad4 <USB_Device_ProcessControlPacket+0x248>
 ade:	fd 01       	movw	r30, r26
 ae0:	11 96       	adiw	r26, 0x01	; 1
			#if defined(USE_RAM_DESCRIPTORS)
			Endpoint_Write_Byte(*((uint8_t*)DescriptorPointer++));
			#elif defined (USE_EEPROM_DESCRIPTORS)
			Endpoint_Write_Byte(eeprom_read_byte(DescriptorPointer++));			
			#else
			Endpoint_Write_Byte(pgm_read_byte(DescriptorPointer++));
 ae2:	e4 91       	lpm	r30, Z
			}

			/** Writes one byte from the currently selected endpoint's bank, for IN direction endpoints. */
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 ae4:	e0 93 f1 00 	sts	0x00F1, r30
			#endif
			
			DescriptorBytesToSend--;
 ae8:	21 50       	subi	r18, 0x01	; 1
 aea:	30 40       	sbci	r19, 0x00	; 0
	
	while (DescriptorBytesToSend && (!(Endpoint_IsSetupOUTReceived())))
	{
		while (!(Endpoint_IsSetupINReady()));
		
		while (DescriptorBytesToSend && (Endpoint_BytesInEndpoint() < USB_ControlEndpointSize))
 aec:	21 f0       	breq	.+8      	; 0xaf6 <USB_Device_ProcessControlPacket+0x26a>
 aee:	80 91 f2 00 	lds	r24, 0x00F2
 af2:	89 17       	cp	r24, r25
 af4:	a0 f3       	brcs	.-24     	; 0xade <USB_Device_ProcessControlPacket+0x252>
			#endif
			
			DescriptorBytesToSend--;
		}
		
		Endpoint_ClearSetupIN();
 af6:	80 91 e8 00 	lds	r24, 0x00E8
 afa:	8e 7f       	andi	r24, 0xFE	; 254
 afc:	80 93 e8 00 	sts	0x00E8, r24
	if (DescriptorBytesToSend > DescriptorSize)
	  DescriptorBytesToSend = DescriptorSize;
	  
	SendZLP = !(DescriptorBytesToSend % USB_ControlEndpointSize);
	
	while (DescriptorBytesToSend && (!(Endpoint_IsSetupOUTReceived())))
 b00:	21 15       	cp	r18, r1
 b02:	31 05       	cpc	r19, r1
 b04:	21 f0       	breq	.+8      	; 0xb0e <USB_Device_ProcessControlPacket+0x282>
 b06:	80 91 e8 00 	lds	r24, 0x00E8
 b0a:	82 ff       	sbrs	r24, 2
 b0c:	e3 cf       	rjmp	.-58     	; 0xad4 <USB_Device_ProcessControlPacket+0x248>
		}
		
		Endpoint_ClearSetupIN();
	}
	
	if (Endpoint_IsSetupOUTReceived())
 b0e:	80 91 e8 00 	lds	r24, 0x00E8
 b12:	82 fd       	sbrc	r24, 2
 b14:	27 c0       	rjmp	.+78     	; 0xb64 <USB_Device_ProcessControlPacket+0x2d8>
	{
		Endpoint_ClearSetupOUT();
		return;
	}
	
	if (SendZLP)
 b16:	ca 01       	movw	r24, r20
 b18:	35 d1       	rcall	.+618    	; 0xd84 <__udivmodhi4>
 b1a:	89 2b       	or	r24, r25
 b1c:	49 f4       	brne	.+18     	; 0xb30 <USB_Device_ProcessControlPacket+0x2a4>
	{
		while (!(Endpoint_IsSetupINReady()));
 b1e:	80 91 e8 00 	lds	r24, 0x00E8
 b22:	80 ff       	sbrs	r24, 0
 b24:	fc cf       	rjmp	.-8      	; 0xb1e <USB_Device_ProcessControlPacket+0x292>
		Endpoint_ClearSetupIN();
 b26:	80 91 e8 00 	lds	r24, 0x00E8
 b2a:	8e 7f       	andi	r24, 0xFE	; 254
 b2c:	80 93 e8 00 	sts	0x00E8, r24
	}

   while (!(Endpoint_IsSetupOUTReceived()));
 b30:	80 91 e8 00 	lds	r24, 0x00E8
 b34:	82 ff       	sbrs	r24, 2
 b36:	fc cf       	rjmp	.-8      	; 0xb30 <USB_Device_ProcessControlPacket+0x2a4>
 b38:	15 c0       	rjmp	.+42     	; 0xb64 <USB_Device_ProcessControlPacket+0x2d8>
			USB_Device_GetDescriptor();
			RequestHandled = true;
			
			break;
		case REQ_GetConfiguration:
			if (RequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
 b3a:	60 38       	cpi	r22, 0x80	; 128
 b3c:	09 f0       	breq	.+2      	; 0xb40 <USB_Device_ProcessControlPacket+0x2b4>
 b3e:	41 c0       	rjmp	.+130    	; 0xbc2 <USB_Device_ProcessControlPacket+0x336>
	RAISE_EVENT(USB_ConfigurationChanged);
}

void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSetupReceived();	
 b40:	80 91 e8 00 	lds	r24, 0x00E8
 b44:	87 7f       	andi	r24, 0xF7	; 247
 b46:	80 93 e8 00 	sts	0x00E8, r24

	Endpoint_Write_Byte(USB_ConfigurationNumber);
 b4a:	80 91 4f 01 	lds	r24, 0x014F
 b4e:	80 93 f1 00 	sts	0x00F1, r24
	
	Endpoint_ClearSetupIN();
 b52:	80 91 e8 00 	lds	r24, 0x00E8
 b56:	8e 7f       	andi	r24, 0xFE	; 254
 b58:	80 93 e8 00 	sts	0x00E8, r24

	while (!(Endpoint_IsSetupOUTReceived()));
 b5c:	80 91 e8 00 	lds	r24, 0x00E8
 b60:	82 ff       	sbrs	r24, 2
 b62:	fc cf       	rjmp	.-8      	; 0xb5c <USB_Device_ProcessControlPacket+0x2d0>
	Endpoint_ClearSetupOUT();
 b64:	80 91 e8 00 	lds	r24, 0x00E8
 b68:	8b 7f       	andi	r24, 0xFB	; 251
 b6a:	80 93 e8 00 	sts	0x00E8, r24
 b6e:	2b c0       	rjmp	.+86     	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
				RequestHandled = true;
			}

			break;
		case REQ_SetConfiguration:
			if (RequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
 b70:	66 23       	and	r22, r22
 b72:	39 f5       	brne	.+78     	; 0xbc2 <USB_Device_ProcessControlPacket+0x336>
		/* Inline Functions: */
			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints. */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 b74:	f0 90 f1 00 	lds	r15, 0x00F1
}

static void USB_Device_SetConfiguration(void)
{
	uint8_t                  ConfigNum     = Endpoint_Read_Byte();
	uint8_t                  PrevConfigNum = USB_ConfigurationNumber;
 b78:	e0 90 4f 01 	lds	r14, 0x014F
	USB_Descriptor_Device_t* DevDescriptorPtr;
	uint16_t                 DevDescriptorSize;

	if ((USB_GetDescriptor(DTYPE_Device, 0, 0, (void*)&DevDescriptorPtr, &DevDescriptorSize) == false) ||
 b7c:	8e 01       	movw	r16, r28
 b7e:	09 5f       	subi	r16, 0xF9	; 249
 b80:	1f 4f       	sbci	r17, 0xFF	; 255
 b82:	9e 01       	movw	r18, r28
 b84:	2b 5f       	subi	r18, 0xFB	; 251
 b86:	3f 4f       	sbci	r19, 0xFF	; 255
 b88:	40 e0       	ldi	r20, 0x00	; 0
 b8a:	50 e0       	ldi	r21, 0x00	; 0
 b8c:	81 e0       	ldi	r24, 0x01	; 1
 b8e:	11 dd       	rcall	.-1502   	; 0x5b2 <USB_GetDescriptor>
 b90:	88 23       	and	r24, r24
 b92:	c9 f0       	breq	.+50     	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
#if defined(USE_RAM_DESCRIPTORS)
	    (ConfigNum > DevDescriptorPtr->NumberOfConfigurations))
#elif defined (USE_EEPROM_DESCRIPTORS)
	    (ConfigNum > eeprom_read_byte(&DevDescriptorPtr->NumberOfConfigurations)))
#else
	    (ConfigNum > pgm_read_byte(&DevDescriptorPtr->NumberOfConfigurations)))
 b94:	ed 81       	ldd	r30, Y+5	; 0x05
 b96:	fe 81       	ldd	r31, Y+6	; 0x06
 b98:	71 96       	adiw	r30, 0x11	; 17
 b9a:	e4 91       	lpm	r30, Z
	uint8_t                  ConfigNum     = Endpoint_Read_Byte();
	uint8_t                  PrevConfigNum = USB_ConfigurationNumber;
	USB_Descriptor_Device_t* DevDescriptorPtr;
	uint16_t                 DevDescriptorSize;

	if ((USB_GetDescriptor(DTYPE_Device, 0, 0, (void*)&DevDescriptorPtr, &DevDescriptorSize) == false) ||
 b9c:	ef 15       	cp	r30, r15
 b9e:	98 f0       	brcs	.+38     	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>
#endif
	{
		return;
	}
	
	USB_ConfigurationNumber = ConfigNum;
 ba0:	f0 92 4f 01 	sts	0x014F, r15

	Endpoint_ClearSetupReceived();
 ba4:	80 91 e8 00 	lds	r24, 0x00E8
 ba8:	87 7f       	andi	r24, 0xF7	; 247
 baa:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearSetupIN();
 bae:	80 91 e8 00 	lds	r24, 0x00E8
 bb2:	8e 7f       	andi	r24, 0xFE	; 254
 bb4:	80 93 e8 00 	sts	0x00E8, r24

	if (!(PrevConfigNum))
 bb8:	ee 20       	and	r14, r14
 bba:	09 f4       	brne	.+2      	; 0xbbe <USB_Device_ProcessControlPacket+0x332>
	  RAISE_EVENT(USB_DeviceEnumerationComplete);
 bbc:	c3 d0       	rcall	.+390    	; 0xd44 <Event_USB_DeviceEnumerationComplete>

	RAISE_EVENT(USB_ConfigurationChanged);
 bbe:	6b db       	rcall	.-2346   	; 0x296 <Event_USB_ConfigurationChanged>
 bc0:	02 c0       	rjmp	.+4      	; 0xbc6 <USB_Device_ProcessControlPacket+0x33a>

			break;
	}

	if (!(RequestHandled))
	  RAISE_EVENT(USB_UnhandledControlPacket, Request, RequestType);
 bc2:	89 2f       	mov	r24, r25
 bc4:	84 db       	rcall	.-2296   	; 0x2ce <Event_USB_UnhandledControlPacket>
	  
	if (Endpoint_IsSetupReceived())
 bc6:	80 91 e8 00 	lds	r24, 0x00E8
 bca:	83 ff       	sbrs	r24, 3
 bcc:	0a c0       	rjmp	.+20     	; 0xbe2 <USB_Device_ProcessControlPacket+0x356>
	{
		Endpoint_StallTransaction();
 bce:	80 91 eb 00 	lds	r24, 0x00EB
 bd2:	80 62       	ori	r24, 0x20	; 32
 bd4:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ClearSetupReceived();		
 bd8:	80 91 e8 00 	lds	r24, 0x00E8
 bdc:	87 7f       	andi	r24, 0xF7	; 247
 bde:	80 93 e8 00 	sts	0x00E8, r24
 be2:	28 96       	adiw	r28, 0x08	; 8
 be4:	0f b6       	in	r0, 0x3f	; 63
 be6:	f8 94       	cli
 be8:	de bf       	out	0x3e, r29	; 62
 bea:	0f be       	out	0x3f, r0	; 63
 bec:	cd bf       	out	0x3d, r28	; 61
 bee:	df 91       	pop	r29
 bf0:	cf 91       	pop	r28
 bf2:	1f 91       	pop	r17
 bf4:	0f 91       	pop	r16
 bf6:	ff 90       	pop	r15
 bf8:	ef 90       	pop	r14
 bfa:	08 95       	ret

00000bfc <USB_USBTask>:
#if defined(USB_CAN_BE_HOST)
volatile uint8_t   USB_HostState;
#endif

TASK(USB_USBTask)
{
 bfc:	1f 93       	push	r17
#endif

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_IsConnected)
 bfe:	80 91 51 01 	lds	r24, 0x0151
 c02:	88 23       	and	r24, r24
 c04:	61 f0       	breq	.+24     	; 0xc1e <USB_USBTask+0x22>
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();
 c06:	10 91 e9 00 	lds	r17, 0x00E9
	
		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
 c0a:	10 92 e9 00 	sts	0x00E9, r1

		if (Endpoint_IsSetupReceived())
 c0e:	80 91 e8 00 	lds	r24, 0x00E8
 c12:	83 ff       	sbrs	r24, 3
 c14:	01 c0       	rjmp	.+2      	; 0xc18 <USB_USBTask+0x1c>
		  USB_Device_ProcessControlPacket();
 c16:	3a de       	rcall	.-908    	; 0x88c <USB_Device_ProcessControlPacket>
#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_IsConnected)
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();
 c18:	17 70       	andi	r17, 0x07	; 7
		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSetupReceived())
		  USB_Device_ProcessControlPacket();
		  
		Endpoint_SelectEndpoint(PrevEndpoint);
 c1a:	10 93 e9 00 	sts	0x00E9, r17
 c1e:	1f 91       	pop	r17
 c20:	08 95       	ret

00000c22 <__vector_11>:

#include "../LowLevel/USBMode.h"
#include "USBInterrupt.h"

ISR(USB_GEN_vect)
{
 c22:	1f 92       	push	r1
 c24:	0f 92       	push	r0
 c26:	0f b6       	in	r0, 0x3f	; 63
 c28:	0f 92       	push	r0
 c2a:	11 24       	eor	r1, r1
 c2c:	2f 93       	push	r18
 c2e:	3f 93       	push	r19
 c30:	4f 93       	push	r20
 c32:	5f 93       	push	r21
 c34:	6f 93       	push	r22
 c36:	7f 93       	push	r23
 c38:	8f 93       	push	r24
 c3a:	9f 93       	push	r25
 c3c:	af 93       	push	r26
 c3e:	bf 93       	push	r27
 c40:	ef 93       	push	r30
 c42:	ff 93       	push	r31
			USB_IsConnected = false;
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPEND) && USB_INT_IsEnabled(USB_INT_SUSPEND))
 c44:	80 91 e1 00 	lds	r24, 0x00E1
 c48:	80 ff       	sbrs	r24, 0
 c4a:	1d c0       	rjmp	.+58     	; 0xc86 <__vector_11+0x64>
 c4c:	80 91 e2 00 	lds	r24, 0x00E2
 c50:	80 ff       	sbrs	r24, 0
 c52:	19 c0       	rjmp	.+50     	; 0xc86 <__vector_11+0x64>
	{
		USB_INT_Clear(USB_INT_SUSPEND);
 c54:	80 91 e1 00 	lds	r24, 0x00E1
 c58:	8e 7f       	andi	r24, 0xFE	; 254
 c5a:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_SUSPEND);
 c5e:	80 91 e2 00 	lds	r24, 0x00E2
 c62:	8e 7f       	andi	r24, 0xFE	; 254
 c64:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUP);
 c68:	80 91 e2 00 	lds	r24, 0x00E2
 c6c:	80 61       	ori	r24, 0x10	; 16
 c6e:	80 93 e2 00 	sts	0x00E2, r24
		
		USB_CLK_Freeze();
 c72:	80 91 d8 00 	lds	r24, 0x00D8
 c76:	80 62       	ori	r24, 0x20	; 32
 c78:	80 93 d8 00 	sts	0x00D8, r24
		#if !defined(MANUAL_PLL_CONTROL)
		USB_PLL_Off();
 c7c:	19 bc       	out	0x29, r1	; 41
		#endif

		RAISE_EVENT(USB_Suspend);
 c7e:	62 d0       	rcall	.+196    	; 0xd44 <Event_USB_DeviceEnumerationComplete>

		#if defined(USB_LIMITED_CONTROLLER)
		USB_IsConnected = false;
 c80:	10 92 51 01 	sts	0x0151, r1
		RAISE_EVENT(USB_Disconnect);
 c84:	ec da       	rcall	.-2600   	; 0x25e <Event_USB_Disconnect>
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUP) && USB_INT_IsEnabled(USB_INT_WAKEUP))
 c86:	80 91 e1 00 	lds	r24, 0x00E1
 c8a:	84 ff       	sbrs	r24, 4
 c8c:	24 c0       	rjmp	.+72     	; 0xcd6 <__vector_11+0xb4>
 c8e:	80 91 e2 00 	lds	r24, 0x00E2
 c92:	84 ff       	sbrs	r24, 4
 c94:	20 c0       	rjmp	.+64     	; 0xcd6 <__vector_11+0xb4>
	{
		#if !defined(MANUAL_PLL_CONTROL)
		USB_PLL_On();
 c96:	19 bc       	out	0x29, r1	; 41
 c98:	89 b5       	in	r24, 0x29	; 41
 c9a:	82 60       	ori	r24, 0x02	; 2
 c9c:	89 bd       	out	0x29, r24	; 41
		#endif
		while (!(USB_PLL_IsReady()));
 c9e:	09 b4       	in	r0, 0x29	; 41
 ca0:	00 fe       	sbrs	r0, 0
 ca2:	fd cf       	rjmp	.-6      	; 0xc9e <__vector_11+0x7c>

		USB_CLK_Unfreeze();
 ca4:	80 91 d8 00 	lds	r24, 0x00D8
 ca8:	8f 7d       	andi	r24, 0xDF	; 223
 caa:	80 93 d8 00 	sts	0x00D8, r24

		USB_INT_Clear(USB_INT_WAKEUP);
 cae:	80 91 e1 00 	lds	r24, 0x00E1
 cb2:	8f 7e       	andi	r24, 0xEF	; 239
 cb4:	80 93 e1 00 	sts	0x00E1, r24

		USB_INT_Disable(USB_INT_WAKEUP);
 cb8:	80 91 e2 00 	lds	r24, 0x00E2
 cbc:	8f 7e       	andi	r24, 0xEF	; 239
 cbe:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_SUSPEND);
 cc2:	80 91 e2 00 	lds	r24, 0x00E2
 cc6:	81 60       	ori	r24, 0x01	; 1
 cc8:	80 93 e2 00 	sts	0x00E2, r24
		
		#if defined(USB_LIMITED_CONTROLLER)
		USB_IsConnected = true;
 ccc:	81 e0       	ldi	r24, 0x01	; 1
 cce:	80 93 51 01 	sts	0x0151, r24
		RAISE_EVENT(USB_Connect);
 cd2:	d9 da       	rcall	.-2638   	; 0x286 <Event_USB_Connect>
		#endif

		RAISE_EVENT(USB_WakeUp);
 cd4:	37 d0       	rcall	.+110    	; 0xd44 <Event_USB_DeviceEnumerationComplete>
	}
   
	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
 cd6:	80 91 e1 00 	lds	r24, 0x00E1
 cda:	83 ff       	sbrs	r24, 3
 cdc:	22 c0       	rjmp	.+68     	; 0xd22 <__vector_11+0x100>
 cde:	80 91 e2 00 	lds	r24, 0x00E2
 ce2:	83 ff       	sbrs	r24, 3
 ce4:	1e c0       	rjmp	.+60     	; 0xd22 <__vector_11+0x100>
	{
		USB_INT_Clear(USB_INT_EORSTI);
 ce6:	80 91 e1 00 	lds	r24, 0x00E1
 cea:	87 7f       	andi	r24, 0xF7	; 247
 cec:	80 93 e1 00 	sts	0x00E1, r24

		USB_ConfigurationNumber = 0;
 cf0:	10 92 4f 01 	sts	0x014F, r1

		USB_INT_Clear(USB_INT_SUSPEND);
 cf4:	80 91 e1 00 	lds	r24, 0x00E1
 cf8:	8e 7f       	andi	r24, 0xFE	; 254
 cfa:	80 93 e1 00 	sts	0x00E1, r24
		USB_INT_Disable(USB_INT_SUSPEND);
 cfe:	80 91 e2 00 	lds	r24, 0x00E2
 d02:	8e 7f       	andi	r24, 0xFE	; 254
 d04:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Enable(USB_INT_WAKEUP);
 d08:	80 91 e2 00 	lds	r24, 0x00E2
 d0c:	80 61       	ori	r24, 0x10	; 16
 d0e:	80 93 e2 00 	sts	0x00E2, r24

		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
 d12:	60 91 1b 01 	lds	r22, 0x011B
 d16:	77 27       	eor	r23, r23
 d18:	20 e0       	ldi	r18, 0x00	; 0
 d1a:	40 e0       	ldi	r20, 0x00	; 0
 d1c:	80 e0       	ldi	r24, 0x00	; 0
 d1e:	90 dd       	rcall	.-1248   	; 0x840 <Endpoint_ConfigureEndpoint_P>
		                           ENDPOINT_DIR_OUT, USB_ControlEndpointSize,
		                           ENDPOINT_BANK_SINGLE);

		RAISE_EVENT(USB_Reset);
 d20:	11 d0       	rcall	.+34     	; 0xd44 <Event_USB_DeviceEnumerationComplete>
 d22:	ff 91       	pop	r31
 d24:	ef 91       	pop	r30
 d26:	bf 91       	pop	r27
 d28:	af 91       	pop	r26
 d2a:	9f 91       	pop	r25
 d2c:	8f 91       	pop	r24
 d2e:	7f 91       	pop	r23
 d30:	6f 91       	pop	r22
 d32:	5f 91       	pop	r21
 d34:	4f 91       	pop	r20
 d36:	3f 91       	pop	r19
 d38:	2f 91       	pop	r18
 d3a:	0f 90       	pop	r0
 d3c:	0f be       	out	0x3f, r0	; 63
 d3e:	0f 90       	pop	r0
 d40:	1f 90       	pop	r1
 d42:	18 95       	reti

00000d44 <Event_USB_DeviceEnumerationComplete>:

#define INCLUDE_FROM_EVENTS_C
#include "Events.h"

static void __stub(void)
{
 d44:	08 95       	ret

00000d46 <SPI_MasterInit>:
#include "SPI.h"

void SPI_MasterInit(unsigned char DataOrder)
{
 d46:	90 91 64 00 	lds	r25, 0x0064
 d4a:	9b 7f       	andi	r25, 0xFB	; 251
 d4c:	90 93 64 00 	sts	0x0064, r25
	/* Disable the Power Reduction on Serial Peripheral Interface */
	PRR0 &= ~(1<<PRSPI);
	
	/* Set MOSI, SCK output and SS pins of EEPROM and data lacthes as outputs */
	DDRB |= ((1<<PB0) | (1<<PB1) | (1<<PB2) | (1<<PB4));
 d50:	94 b1       	in	r25, 0x04	; 4
 d52:	97 61       	ori	r25, 0x17	; 23
 d54:	94 b9       	out	0x04, r25	; 4
	/* Enable SPI, Master, set clock rate fck/2 */
	SPCR |= ((1<<SPE) | (1<<MSTR) | (1<<SPI2X));
 d56:	9c b5       	in	r25, 0x2c	; 44
 d58:	91 65       	ori	r25, 0x51	; 81
 d5a:	9c bd       	out	0x2c, r25	; 44

	/* Configure the Data Order of first be to be transmited */
	if (DataOrder)
 d5c:	88 23       	and	r24, r24
 d5e:	19 f0       	breq	.+6      	; 0xd66 <SPI_MasterInit+0x20>
		SPCR |= (1<<DORD);
 d60:	8c b5       	in	r24, 0x2c	; 44
 d62:	80 62       	ori	r24, 0x20	; 32
 d64:	8c bd       	out	0x2c, r24	; 44
 d66:	08 95       	ret

00000d68 <SPI_Disable>:
}

void SPI_Disable(void)
{
 d68:	8c b5       	in	r24, 0x2c	; 44
 d6a:	8f 7b       	andi	r24, 0xBF	; 191
 d6c:	8c bd       	out	0x2c, r24	; 44
	/* Disable SPI */
	SPCR &= ~(1<<SPE);
	
	/* Enable the Power Reduction on Serial Peripheral Interface */
	PRR0 |= (1<<PRSPI);
 d6e:	e4 e6       	ldi	r30, 0x64	; 100
 d70:	f0 e0       	ldi	r31, 0x00	; 0
 d72:	80 81       	ld	r24, Z
 d74:	84 60       	ori	r24, 0x04	; 4
 d76:	80 83       	st	Z, r24
 d78:	08 95       	ret

00000d7a <SPI_MasterTransmit>:
}

void SPI_MasterTransmit(unsigned char cData)
{
 d7a:	8e bd       	out	0x2e, r24	; 46
  /* Start transmission */
  SPDR = cData;
  /* Wait for transmission complete */
  while(bit_is_clear(SPSR,SPIF))
 d7c:	0d b4       	in	r0, 0x2d	; 45
 d7e:	07 fe       	sbrs	r0, 7
 d80:	fd cf       	rjmp	.-6      	; 0xd7c <SPI_MasterTransmit+0x2>
 d82:	08 95       	ret

00000d84 <__udivmodhi4>:
 d84:	aa 1b       	sub	r26, r26
 d86:	bb 1b       	sub	r27, r27
 d88:	51 e1       	ldi	r21, 0x11	; 17
 d8a:	07 c0       	rjmp	.+14     	; 0xd9a <__udivmodhi4_ep>

00000d8c <__udivmodhi4_loop>:
 d8c:	aa 1f       	adc	r26, r26
 d8e:	bb 1f       	adc	r27, r27
 d90:	a6 17       	cp	r26, r22
 d92:	b7 07       	cpc	r27, r23
 d94:	10 f0       	brcs	.+4      	; 0xd9a <__udivmodhi4_ep>
 d96:	a6 1b       	sub	r26, r22
 d98:	b7 0b       	sbc	r27, r23

00000d9a <__udivmodhi4_ep>:
 d9a:	88 1f       	adc	r24, r24
 d9c:	99 1f       	adc	r25, r25
 d9e:	5a 95       	dec	r21
 da0:	a9 f7       	brne	.-22     	; 0xd8c <__udivmodhi4_loop>
 da2:	80 95       	com	r24
 da4:	90 95       	com	r25
 da6:	bc 01       	movw	r22, r24
 da8:	cd 01       	movw	r24, r26
 daa:	08 95       	ret

00000dac <_exit>:
 dac:	ff cf       	rjmp	.-2      	; 0xdac <_exit>
