#summary API definition to interaction between HaRdware and SoFtware.

Connecting Bicycle LED POV hardware to PC using an USB cable, a new virtual serial port will appear on PC. Commands are sent to the virtual serial port to interact with Bicycle LED POV HaRdware.

The API have two parts, the “base” one should always be implemented on each hardware and provides minimum functionality while the BicycleLEDPOVExtendedAPI part differs on each hardware and is not necessary to be implement.

=Base API=
===Command not implemented===

Input value(s):
|| *byte number* || *content* ||
|| 01 || xx ||

Output value(s):
|| *byte number* || *content* ||
|| 01 || lenght of the next string. ||
|| 02 and following bytes || "command not implemented". The string must be terminated with a null char. ||

==Hardware==
===Command 1: Get identificacion string===

Input value(s):
|| *byte number* || *content* ||
|| 01 || 01 ||

Output value(s):
|| *byte number* || *content* ||
|| 01 || lenght of the next string. ||
|| 02 and following bytes || Example string: "Bicycle LED POV r1.1 fw1.0 20081022". The string must be terminated with a null char. ||

===Command 2: Get hardware properties===

Input value(s):
|| *byte number* || *content* ||
|| 02 || 02 ||

Output value(s):
|| *byte number* || *content* ||
|| 01 || lenght of the next following bytes. ||
|| 02 || API version. ||
|| 03 || extended API version. ||
|| 04 || firmware version. ||
|| 05 || byte 01 of number of radial lines. ||
|| 06 || byte 02 of number of radial lines. ||
|| 07 || byte 01 of number of LEDs per radial line. ||
|| 08 || byte 02 of number of LEDs per radial line. ||
|| 09 || byte 01 of number of animations images colors properties. ||
|| 10 || byte 02 of number of animations images colors properties. ||
|| 11 || byte 03 of number of animations images colors properties. ||
|| 12 || byte 04 of number of animations images colors properties. ||
|| 13 || byte 01 of number of number of independent LED-strips. ||

==Memory==
===Command 10: Clear all memory===

Input value(s):
|| *byte number* || *content* ||
|| 01 || 10 ||

Output value(s):
|| *byte number* || *content* ||
|| 01 || lenght of the next following bytes. ||
|| 02 || byte 01 of lenght of cleared bytes. ||
|| 03 || byte 02 of lenght of cleared bytes. ||

===Command 11: Read a stream of bytes from memory===

Input value(s):
|| *byte number* || *content* ||
|| 01 || 11 ||
|| 02 || byte 01 of number of bytes of the stream to read. ||
|| 03 || byte 02 of number of bytes of the stream to read. ||
|| 04 || byte 01 of address of memory, of the beguining of the stream to read. ||
|| 05 || byte 02 of address of memory, of the beguining of the stream to read. ||
|| 06 || byte 03 of address of memory, of the beguining of the stream to read. ||
|| 07 || byte 04 of address of memory, of the beguining of the stream to read. ||

Output value(s):
|| *byte number* || *content* ||
|| 01 || lenght of the next following bytes. ||
|| 02 || byte 01 of lenght of stream to read. ||
|| 03 || byte 02 of lenght of stream to read. ||
|| 04 and following bytes || byte of stream readed. ||

===Command 12: Write a stream of bytes to memory===

Input value(s):
|| *byte number* || *content* ||
|| 01 || 12 ||
|| 02 || byte 01 of lenght of stream to write. ||
|| 03 || byte 02 of lenght of stream to write. ||
|| 04 || byte 01 of address of memory, of the beguining of the stream to write. ||
|| 05 || byte 02 of address of memory, of the beguining of the stream to write. ||
|| 06 || byte 03 of address of memory, of the beguining of the stream to write. ||
|| 07 || byte 04 of address of memory, of the beguining of the stream to write. ||
|| 08 and following bytes || byte of stream to write. ||

Output value(s):
|| *byte number* || *content* ||
|| 01 || lenght of the next following bytes. ||
|| 02 || byte 01 of lenght of written bytes. ||
|| 03 || byte 02 of lenght of written bytes. ||